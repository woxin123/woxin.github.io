<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CORS跨域详解]]></title>
    <url>%2F2019%2F05%2F08%2FCORS%E8%B7%A8%E5%9F%9F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[转载自阮一峰，链接：http://www.ruanyifeng.com/blog/2016/04/cors.html 一、简介CORS是一个W3C标准，全称是“跨域资源共享”（Corss-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。目前，所有的浏览器都支持该功能，IE浏览器的内核不能低于IE10。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对开发者来说，CORS通信与源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX跨域，就会自动添加一些附加的头信息，有时还会多出一次附加请求，但用户感觉不到。 二、两种请求浏览器将CORS请求分为两类：简单请求（simple request）和非简单请求（not-so-simple request）。 只要满足一下两大条件，就属于非简单请求。 请求方法是以下三个方法之一： HEAD GET POST HTTP 的头信息不超出以下几个字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于application/x-www-form-urlencode、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。 浏览器对于这两种请求的处理，是不一样的。 三、简单请求3.1 基本流程对于简单请求，浏览器直接发出CORS请求。具体来说。就是在头信息之中，增加一个Origin字段。 下面是一个例子，浏览器发现这次跨域AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。 123456GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 下面的头信息，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器更具这个值，决定是否同意这次请求。 如果Origin指定的源，不在许可范围内，服务器就返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。 （1）Access-Control-Allow-Origin该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接收任意域名请求。 （2）Access-Control-Allow-Credentials该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求中。设为true表示服务器明确许可，Cookie可以包含在请求中，一起发送给服务器。这个值只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 （3）Access-Control-Expose-Headers该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。 如果想要拿到其他字段，就必须在Access-Control-Headers里面指定。上面的例子指定，getResponseHeader(&#39;FooBar&#39;)可以返回FooBar字段的值。 3.2 withCredentials属性上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发送到服务器，一方面要服务器通信，指定Access-Control-Allow-Credentials字段。 1Access-Control-Allow-Credentials: true 另一方面，开发者必须在AJAX请求中打开withCredentials属性。 12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。 但是，如果省略withCredentials设置，有的浏览器还是会发送Cookie。这时，可以显示关闭withCredentials。 1xhr.withCredentials = false; 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设置为*号，必须明确的、与请求网页一致的域名。同时，Cookie依然遵循同源策略。只有服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 四、非简单请求4.1 预测请求非简单请求是那种对服务器有特殊要求的请求，比如请求的方法是PUT或DELETE，或者Content-Type字段的类型是application/json。 非简单请求的CORS，会在正式通信之前，增加一次HTTP查询请求，称为“预测”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到了肯定答复，浏览器才会正式的XMLHttpRequest请求，否则就报错。 下面是一段浏览器的JavaScript脚本。 12345var url = 'http://api.alice.com/cors';var xhr = new XMLHttpRequest();xhr.open('PUT', url, true);xhr.setRequestHeader('X-Custom-Header', 'value');xhr.send(); 上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。 浏览器发现，这是一个非简单请求，就自动发出一个“预测”请求，要求服务器确认可以这样请求。下面是这个“预测”请求的HTTP头信息。 12345678OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... “预测”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字是Origin，表示请求来自哪个源。 除了Origin字段，“预测”请求的头信息包括两个特殊字段。 （1）Access-Control-Request-Method该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。 （2）Access-Control-Request-Headers该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例X-Custom-Header。 4.2 预测请求的回应服务器收到“预测”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨域请求，回应。 123456789101112HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 上面的HTTP回应中，关键的是Access-Control-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为*号，表示同意任意跨域资源。 1Access-Control-Allow-Origin: * 如果浏览器否定了“预测”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息。这是，浏览器会认定，服务器不同预测请求，因此会触发一个错误XMLHttpRequest对象的onerror回调函数捕获，控制台会打印出如下报错信息。 12XMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器回应的其他CORS相关字段如下。 1234Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods该字段必须，它的值是逗号分隔的一个字符串，表名服务器支持的跨域请求的方法，注意，返回的是所有支持的方法，而不是浏览器请求的那个方法。这是为了多次“预测”请求。 （2）Access-Control-Allow-Headers如果浏览器请求包括Access-Control-Request-Header字段，则Access-Control-Allow-Headers字段是必须的。它是一个逗号分隔的字符串，表名服务器支持的所有头信息字段，不限于浏览器在”预测“中请求的字段。 （3）Access-Control-Allow-Credentials该字段与简单请求时的含义相同。 （4）Access-Control-Max-Age该字段可选，用来指定本次预检测请求的有效期，单位为秒。上面的结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间内，不用发出另一条预检测请求。 4.3 浏览器的正常请求回应一旦服务器通过了”预测“请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器回应，也都会有一个Access-Control-Allow-Origin头信息字段。 1234567PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 下面是服务器的正常回应。 12Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8 上面的头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CORS</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal详解]]></title>
    <url>%2F2019%2F04%2F22%2FThreadLocal%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[ThreadLocal详解简述ThreadLocal类可以理解为线程本地变量。也就是说如果定义了一个ThreadLocal，每个线程往这个ThreadLocal中读写是线程隔离，互不影响的。它提供了一种将可变数据通过每个线程都有自己独立副本从而实现线程封闭机制。 关于Thread类。每一个线程都有一个Thread对象，这个对象有一些线程私有的变量和常量，比如线程ID，线程的状态，线程是否中断等等信息。而且在这里类里面有一个threadLocals变量，这个变量是一个ThreadLocal.ThreadLocalMap，这个类型是一个Map，这个Map中保存了这个线程所有的线程本地变量。 1ThreadLocal.ThreadLocalMap threadLocals = null; 源码解读存储结构key-value的形式存储，可以简单将ThreadLocal视为key，value为实际存放的值。之所以说是简单视为，是因为实际上ThreadLocal中存放的是ThreadLocal的弱引用。 123456789static class Entry extends WeakReference&lt;java.lang.ThreadLocal&lt;?&gt;&gt; &#123; // 往ThreadLocal里实际塞入的值 Object value; Entry(java.lang.ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; Entry是ThreadLocalMap里定义的节点，它继承了WeakReference类，定义了一个类型为Object的value，用于存放放入ThreadLocal里的值。 为何使用弱引用 如果使用普通的key-value形式来定义存储结构，实质上就会造成节点的生命周期与线程绑定，只要线程没有销毁，那么节点在GC可达性分析中一直处于可达状态，没有办法回收，而程序本身也无法判断是否可以清理节点。 弱引用是Java中四档引用的第三挡，比软引用更加弱一些，如果一个对象没有强引用链可达，那么一般活不过下一次GC。 当某个ThreadLocal已经没有强引用可达，则随着它被垃圾回收，在ThreadLocalMap里对应的Entry的建值会失效，这为ThreadLocalMap本身的垃圾清理提供了便利。 类成员变量与相应方法12345678910111213141516171819/** * 初始容量，必须为2的幂 */private static final int INITIAL_CAPACITY = 16;/** * Entry表，大小必须为2的幂 */private Entry[] table;/** * 表里entry的个数 */private int size = 0;/** * 重新分配表大小的阈值，默认为0 */private int threshold; ThreadLocalMap维护了一个Entry表或者说数组，并且要求表的大小为2的N次幂，同时记录表里面entry的个数以及下一次需要扩容的阈值。 为什么是2的N次幂。 1234567891011121314151617181920/** * 设置resize阈值以维持最坏2/3的装载因子 */private void setThreshold(int len) &#123; threshold = len * 2 / 3;&#125;/** * 环形意义的下一个索引 */private static int nextIndex(int i, int len) &#123; return ((i + 1 &lt; len) ? i + 1 : 0);&#125;/** * 环形意义的上一个索引 */private static int prevIndex(int i, int len) &#123; return ((i - 1 &gt;= 0) ? i - 1 : len - 1);&#125; ThreadLocal需要维持一个最坏2/3的负载因子。 ThreadLocal中有两个方法用于得到上一个/下一个索引，这里实际上是环形意义的上一个与下一个。 由于ThreadLocalMap使用线程探测法来解决散列冲突，所以实际上Entry[]数组在程序上是作为一个环形存在的。以下是ThreadLocalMap的内部存储结构： ThreadLocalMap维护了Entry环形数组，数组元Entry的逻辑上的key为某个ThreadLocal对象（实际上是指向该ThreadLocal对象的弱引用），value为代码中该线程往ThreadLocal变量中放入的实际值。 构造函数12345678910111213141516/** * 构造一个包含firstKey和firstValue的map。 * ThreadLocalMap是惰性构造的，所以只有当至少要往里面放一个元素的时候才会构建它。 */ThreadLocalMap(java.lang.ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; // 初始化table数组 table = new Entry[INITIAL_CAPACITY]; // 用firstKey的threadLocalHashCode与初始大小16取模得到哈希值 int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); // 初始化该节点 table[i] = new Entry(firstKey, firstValue); // 设置节点表大小为1 size = 1; // 设定扩容阈值 setThreshold(INITIAL_CAPACITY);&#125; 这个构造函数在set和get的时候都可能会被间接调用以初始化线程的ThreadLocalMap。 哈希函数ThreadLocal类中有一个被final修饰的类型为int的threadLocalHashCode，它在该ThreadLocal被构造的时候就会生成，相当于一个ThreadLocal的ID，它的值来源于： 12345678/* * 生成hash code间隙为这个魔数，可以让生成出来的值或者说ThreadLocal的ID较为均匀地分布在2的幂大小的数组中。 */private static final int HASH_INCREMENT = 0x61c88647;private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT);&#125; 它是在上一个被构造出的ThreadLocal的ID/threadLocalHashCode的基础上在加上一个魔数0x61c88647的。这个魔数的选取与斐波那契散列有关，0x61c88647对应的十进制为1640531527.斐波那契散列的乘数可以用（long）（（1L&lt;&lt;31）*（Math.sqrt（5）- 1 ））可以得到2654435769，如果把这个值转为带符号的int，则会得到-1640531527. （（1L&lt;&lt;31）*（Math.sqrt（5）- 1 ））得到的结果就是1640531527也就是0x61c88647.当我们用0x61c88647作为魔数累加为每个ThreadLocal分配各自的ID也就是threadLocalHashCode再与2的幂取模，得到的结果分布很均匀。 ThreadLocalMap使用的是线性探测法，均匀分布的好处在于很快就能探测到下一个临近的可用点，从而保证效率。 大小取2的N次幂就是为了优化效率。 下面我写了一段测试程序： 1234567891011121314151617181920public class ThreadLocalHashCodeTest &#123; private static final int HASH_INCREMENT = 0x61c88647; public static void main(String[] args) &#123; int hashCode = 0; int size = 1 &lt;&lt; 4; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for (int i = 1; i &lt;= size; i++) &#123; hashCode = i * HASH_INCREMENT; if (set.contains(hashCode &amp; (size - 1))) &#123; System.out.println("重复"); &#125; set.add(hashCode &amp; (size - 1)); System.out.print((hashCode &amp; (size - 1)) + " "); &#125; System.out.println(); &#125;&#125; 结果： 1237 14 5 12 3 10 1 8 15 6 13 4 11 2 9 07 14 21 28 3 10 17 24 31 6 13 20 27 2 9 16 23 30 5 12 19 26 1 8 15 22 29 4 11 18 25 0 测试结果发现只是打印了每一个求\&amp;的结果，并没有打印出重复。所以说，可以通过这个魔数构造出一个完美散列，没有任何冲突。 getEntry方法这个方法会被ThreadLocal的get方法直接调用，用于获取map中某个ThreadLocal存放的值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; // 根据key这个ThreadLocal的ID来获取索引，也即哈希值 int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; // 对应的entry存在且未失效且弱引用指向的ThreadLocal就是key，则命中返回 if (e != null &amp;&amp; e.get() == key) &#123; return e; &#125; else &#123; // 因为用的是线性探测，所以往后找还是有可能能够找到目标Entry的。 return getEntryAfterMiss(key, i, e); &#125;&#125;/* * 调用getEntry未直接命中的时候调用此方法 */private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; // 基于线性探测法不断向后探测直到遇到空entry。 while (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); // 找到目标 if (k == key) &#123; return e; &#125; if (k == null) &#123; // 该entry对应的ThreadLocal已经被回收，调用expungeStaleEntry来清理无效的entry expungeStaleEntry(i); &#125; else &#123; // 环形意义下往后面走 i = nextIndex(i, len); &#125; e = tab[i]; &#125; return null;&#125;/** * 这个函数是ThreadLocal中核心清理函数，它做的事情很简单： * 就是从staleSlot开始遍历，将无效（弱引用指向对象被回收）清理，即对应entry中的value置为null，将指向这个entry的table[i]置为null，直到扫到空entry。 * 另外，在过程中还会对非空的entry作rehash。 * 可以说这个函数的作用就是从staleSlot开始清理连续段中的slot（断开强引用，rehash slot等） */private int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; // 因为entry对应的ThreadLocal已经被回收，value设为null，显式断开强引用 tab[staleSlot].value = null; // 显式设置该entry为null，以便垃圾回收 tab[staleSlot] = null; size--; Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); // 清理对应ThreadLocal已经被回收的entry if (k == null) &#123; e.value = null; tab[i] = null; size--; &#125; else &#123; /* * 对于还没有被回收的情况，需要做一次rehash。 * * 如果对应的ThreadLocal的ID对len取模出来的索引h不为当前位置i， * 则从h向后线性探测到第一个空的slot，把当前的entry给挪过去。 */ int h = k.threadLocalHashCode &amp; (len - 1); if (h != i) &#123; tab[i] = null; /* * 在原代码的这里有句注释值得一提，原注释如下： * * Unlike Knuth 6.4 Algorithm R, we must scan until * null because multiple entries could have been stale. * * 这段话提及了Knuth高德纳的著作TAOCP（《计算机程序设计艺术》）的6.4章节（散列） * 中的R算法。R算法描述了如何从使用线性探测的散列表中删除一个元素。 * R算法维护了一个上次删除元素的index，当在非空连续段中扫到某个entry的哈希值取模后的索引 * 还没有遍历到时，会将该entry挪到index那个位置，并更新当前位置为新的index， * 继续向后扫描直到遇到空的entry。 * * ThreadLocalMap因为使用了弱引用，所以其实每个slot的状态有三种也即 * 有效（value未回收），无效（value已回收），空（entry==null）。 * 正是因为ThreadLocalMap的entry有三种状态，所以不能完全套高德纳原书的R算法。 * * 因为expungeStaleEntry函数在扫描过程中还会对无效slot清理将之转为空slot， * 如果直接套用R算法，可能会出现具有相同哈希值的entry之间断开（中间有空entry）。 */ while (tab[h] != null) &#123; h = nextIndex(h, len); &#125; tab[h] = e; &#125; &#125; &#125; // 返回staleSlot之后第一个空的slot索引 return i;&#125; 读一个值可能遇到的情况：根据入参threadLcoal的threadLocalHashCode对表容量取模得到index 如果index对应的slot就是要读的threadLocal，则直接返回结果。 调用getEntryAfterMiss线性探测，过程中碰到无效的slot，调用expungeStaleEntry进行段清理；如果找到了key，则返回结果entry； 没有找到key，返回null； set方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len - 1); // 线性探测 // 当hash有冲突的时候 for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); // 找到对应的entry if (k == key) &#123; e.value = value; return; &#125; // 替换失效的entry if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; // 当没有冲突的时候直接放在桶中即可 tab[i] = new Entry(key, value); int sz = ++size; // 如果没有发现失效的值，并且当前容量大于阀值，那么做一个rehash if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) &#123; rehash(); &#125;&#125;private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) &#123; Entry[] tab = table; int len = tab.length; Entry e; // 向前扫描，查找最前一个为空的位置 int slotToExpunge = staleSlot; // 向前扫描扫描到一个为空的位置 for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) &#123; // 如果e.get() == null 那么这里是这个ThreadLcoal已经被回收，此时的这个key就失效了 if (e.get() == null) &#123; slotToExpunge = i; &#125; &#125; // 向后遍历table for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); // 找到了key，将其与无效的slot交换 if (k == key) &#123; // 更新对应slot的value值 e.value = value; // 交换，将它和前面的空的交换 tab[i] = tab[staleSlot]; tab[staleSlot] = e; /* * 如果在向前扫描的过程中遇见了一个是失效的key，那么slotTOExpunge会被改变 */ if (slotToExpunge == staleSlot) &#123; slotToExpunge = i; &#125; // 从slotToExpunge开始做一次连续段的清理，再做一次启发式清理 cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; &#125; // 如果当前的值是一个已经失效的值，并且向前扫描的时候没有发现失效的值，那么把过期需要擦除的位置设置为当前的位置i if (k == null &amp;&amp; slotToExpunge == staleSlot) &#123; slotToExpunge = i; &#125; &#125; // 如果key在table中不存在，则在原地放一个即可 tab[staleSlot].value = null; tab[staleSlot] = new Entry(key, value); // 在探测过程中如果发现任何无效slot，则做一次清理（连续段清理+启发式清理） if (slotToExpunge != staleSlot) &#123; cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); &#125;&#125;private int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; // expunge entry at staleSlot // 擦除staleSolt位置的Entry tab[staleSlot].value = null; tab[staleSlot] = null; size--; // Rehash until we encounter null // 重新hash直到遇到null Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); // 遇到失效的值，然后就把这个失效的值清理掉 if (k == null) &#123; e.value = null; tab[i] = null; size--; &#125; else &#123; // 如果不是失效的值，那么重新做运算获取索引 int h = k.threadLocalHashCode &amp; (len - 1); // 如果不是当前位置 if (h != i) &#123; // 把当前位置置空 tab[i] = null; // Unlike Knuth 6.4 Algorithm R, we must scan until // null because multiple entries could have been stale. // 重新找下一个为空的位置 while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; &#125; &#125; &#125; // 这里返回的i既不是null，也不是一个失效的值 return i;&#125;/** * 启发式地清理slot, * i对应entry是非无效（指向的ThreadLocal没被回收，或者entry本身为空） * n是用于控制控制扫描次数的 * 正常情况下如果log n次扫描没有发现无效slot，函数就结束了 * 但是如果发现了无效的slot，将n置为table的长度len，做一次连续段的清理 * 再从下一个空的slot开始继续扫描 * * 这个函数有两处地方会被调用，一处是插入的时候可能会被调用，另外个是在替换无效slot的时候可能会被调用， * 区别是前者传入的n为元素个数，后者为table的容量 */private boolean cleanSomeSlots(int i, int n) &#123; boolean removed = false; Entry[] tab = table; int len = tab.length; // 每右移一次相当于降了一个2次幂，所以这里总共会循环x次，x是2^x = n do &#123; // i在任何情况下自己都不会是一个无效slot，所以从下一个开始判断 i = nextIndex(i, len); Entry e = tab[i]; // 如果当前的位置是一个失效的值 if (e != null &amp;&amp; e.get() == null) &#123; // 扩大扫描控制因子 n = len; removed = true; // 清理一个连续段 i = expungeStaleEntry(i); &#125; &#125; while ((n &gt;&gt;&gt;= 1) != 0); // 如果发现了失效的值，返回true，否则返回false return removed;&#125;private void rehash() &#123; // 做一次全量清理，在全部清理的过程中进行rehash expungeStaleEntries(); /* * 因为做了一次清理，所以size很可能会变小。 * ThreadLocalMap这里的实现是调低阈值来判断是否需要扩容， * threshold默认为len*2/3，所以这里的threshold - threshold / 4相当于len/2 */ if (size &gt;= threshold - threshold / 4) &#123; resize(); &#125;&#125;/* * 做一次全量清理 */private void expungeStaleEntries() &#123; Entry[] tab = table; int len = tab.length; for (int j = 0; j &lt; len; j++) &#123; Entry e = tab[j]; if (e != null &amp;&amp; e.get() == null) &#123; // 清理当前的值，并且做一个rehash expungeStaleEntry(j); &#125; &#125;&#125;/** * 扩容，因为需要保证table的容量len为2的幂，所以扩容即扩大2倍 */private void resize() &#123; Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (int j = 0; j &lt; oldLen; ++j) &#123; Entry e = oldTab[j]; if (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; &#125; else &#123; // 线性探测来存放Entry int h = k.threadLocalHashCode &amp; (newLen - 1); while (newTab[h] != null) &#123; h = nextIndex(h, newLen); &#125; newTab[h] = e; count++; &#125; &#125; &#125; setThreshold(newLen); size = count; table = newTab;&#125; set方法可能会遇到的情况 探测过程中slot都不无效，并且顺利找到key所在的slot，直接替换即可。 探测过程中发现有无效slot，调用replaceStaleEntry，效果是最终一定会把key和value放这个slot，并且会尽可能清理无效slot 在replaceStaleEntry过程中，如果找到了key，则做一个swap把它放到那个无效slot中，value置为新值； 在replaceStaleEntry过程中，没有找到key，直接在无效slot原地放entry。 探测没有发现key，则在连续段末尾的后一个空位置上放entry，这也是线性探测法的一部分。放完后，做一次启发式清理，如果没有清理出去key，并且当前table大小已经超过阈值了，则做一次rehash，rehash函数会调用一次全量清理slot方法也就是expungeStaleEntries，如果完了之后table大小超过了threshold-threshold/4，则进行扩容2倍。 remove方法12345678910111213141516171819/** * 从map中删除ThreadLocal */private void remove(ThreadLocal&lt;?&gt; key) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len - 1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; if (e.get() == key) &#123; // 显式断开弱引用 e.clear(); // 进行段清理，并且做一个rehash expungeStaleEntry(i); return; &#125; &#125;&#125; remove方法直接在table中找key，如果找到了，把弱引用断了做一次段清理。 ThreadLocal与内存泄漏 关于ThreadLocal是否会引起内存泄漏也是一个比较有争议的问题，其实主要看对内存泄漏的准确定义是什么。 认为ThreadLocal会引起内存泄漏的说法是因为如果一个ThreadLocal对象被回收了，我们往里面放的value对于【当前线程-&gt;当前线程的threadLocals（ThreadLocal.ThreadLocalMap对象）-&gt;Entry数组-&gt;某个entry.value】这样一条强引用链是可达的，因此value不会被回收。 认为ThreadLocal不会引起内存泄漏的说法是因为ThreadLocal.ThreadLocalMap源码实现中自带一套清理机制。 每个thread中都存在一个map，map的类型是ThreadLocal.ThreadLocalMap。Map中的key为一个thread实例，这个Map的确使用了弱引用，不过弱引用只是针对key，每个key都弱引用指向threadlocal。当把threadlocal实例置为null以后，没有任何强引用指向threadlocal实例，所以threadlocal将会被GC回收，但是，我们的value却不能被回收，因为存在一条从current thread连接过来的强引用，只有当前thread结束后，current thread就不会存在栈中，强引用断开，Current Thread，Map，Value将会被GC回收。 所以说只要线程对象被回收就不会发生内存泄漏，但是在threalLocal设为null到线程结束这段时间就不会被回收，就发生了所谓的内存泄漏。 最严重的就是线程对象不被回收的情况，这就发生了真正意义上的内存泄漏，比如使用线程池的时候，线程结束是不会销毁的，会再次使用，就可能出现内存泄漏。 Java为了最小化减少内存泄漏的可能性和影响，在ThreadLocal的get，set的时候都会清除线程Map里所有的key为null的value。所以最坏的情况就是，threadLocal对象设为null了，开始发生“内存泄漏”，然后使用线程池，这个线程结束，线程放回线程池不销毁，这个线程池一直不被使用，或者分配了又不再调用get，set方法，这个期间就会发生真正的内存泄漏，所以建议在使用ThreadLocal手动的调用remove()方法。 总结ThreadLocal类可以理解为线程本地变量。也就是说如果定义了一个ThreadLocal，每个线程往这个ThreadLocal中读写是线程隔离，互不影响的。它提供了一种将可变数据通过每个线程都有自己独立副本从而实现线程封闭机制。 在ThreadLocal中有一个ThreadLocalMap，这个ThreadLocalMap也是一个Map，它的键值是一个ThreadLocal，值是定义的本地线程变量。前面提到了ThreadLocal是一个线程本地变量，这是因为在Thread类中有一个ThreadLocalMap的对象，当前线程中的ThreadLocal对象会被存储在这个ThreadLocalMap对象中。 ThreadLocalMap中的Entry继承了WeakReference，并将ThreadLocal对象设置为弱引用，因为如果当对象中的ThreadLocal对象被设置为空的时候，这个ThreadLocal对象还会被ThreadLocalMap中有一个引用，所以这个对象会被判定是可达的，所以GC不会将这个对象回收，所以就必定会产生内存泄露。因此在这里使用了弱引用。 ThreadLocalMap和HashMap以及Hashtable不同的是ThreadLocalMap使用的Hash算法是线性探测再散列。这里使用的线性探测再散列的方法是如果出现了Hash冲突，然后就找下一个，这里值得注意的一点是它把hash桶设置为一个环，也就是说最后一个元素的下一个元素是第一个元素。 ThreadLocal中有一套自带的清理机制，在get和set的时候都会进行一次无效值清理。在get的时候首先使用和HashMap中相同的通过hash计算索引的方式进行计算，将hash桶中的该位置的key和传入的ThreadLocal对象做比较如果相等，那么然后，如果不相等，继续向下找，如果在找的过程中发现了无效的值，那么从失效值的位置开始进行一次清理，并且进行rehash。set的时候也是类似，不过在set的时候会进行resize，将ThreadLocalMap进行扩容，扩容的时候是将原来的hash桶扩大一倍，然后重新计算位置。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>ThreadLocal</tag>
        <tag>线程封闭</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池详解.md]]></title>
    <url>%2F2019%2F04%2F16%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3-md%2F</url>
    <content type="text"><![CDATA[线程池线程池实现原理当向线程池中提交任务之后，线程池是如何处理这个任务的呢？我们先来看看线程池的主要处理流程，处理流程如下图： 从图中可以看出，当提交一个新任务到线程池时，线程池的处理流程如下。 线程池判断核心线程数是否都在执行。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里面的线程都在执行任务。则进入下一个流程。 线程池判断工作队列是否已经满。如果工作队列没有慢，则将新提交的任务存储在这个工作队列中。如果工作队列满了，则进入下一个流程。 线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的线程来执行任务，如果已经满了，则交给饱和策略来处理这个任务。 ThreadPoolExecutor执行execute()方法的示意图，如下图所示： 如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。 运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。 如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，这一执行步骤需要获取全局锁）。 如果创建新线程将使当前运行的线程超出了maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。 ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能的避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在ThreadPoolExecutorw完成预热之后（当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用都是执行步骤2，而步骤2不需要获取全局锁。 下面我们来通过源码分析ThreadPoolExecutor的工作原理： 12345678910111213141516171819202122232425public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); // 如果线程的数量小于基本线程数，则创建线程并执行当前任务 int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; // 这里重新获取线程池状态 c = ctl.get(); &#125; // 如果线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; // 重新检查线程池状态 int recheck = ctl.get(); // 这里进行重新检测 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; // 如果无法放入阻塞队列中，尝试再次创建线程运行，如果失败了，则执行拒绝逻辑 else if (!addWorker(command, false)) reject(command);&#125; 工作线程：线程池创建线程时，会将线程封装成工作线程Worker,Worker在执行人任务后，还会循环获取工作队列里的任务来执行。我们可以从Worker类的run()f方法里看到这点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void run() &#123; runWorker(this);&#125;final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; // 这里通过循环从阻塞队列里面获取任务来执行 while (task != null || (task = getTask()) != null) &#123; w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt // 如果线程池停止，请确保线程被中断 // 如果没有，请确保线程没有被中断。这里需要在第二种情况下重新检查才能处理 // 以便在清除中断的同时处理立即关闭比赛 if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; beforeExecute(wt, task); try &#123; // 执行任务 task.run(); afterExecute(task, null); &#125; catch (Throwable ex) &#123; afterExecute(task, ex); throw ex; &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125;&#125; ThreadPoolExecutor中线程执行任务的示意图如下所示： 线程池的使用线程池的创建我们可以通过ThreadPoolExecutor来创建一个线程池。 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 我们创建一个线程池时要输入几个参数，如下： corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于基本线程的时候就不在创建了。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。 runableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列，可以选择一下几个阻塞队列。 ArrayBlockingQueue：是一个基于数组结构的有界队列，此队列按FIFO（先进先出）原则对元素进行排序。 LinkedBlockingQueue：一个基于链表的阻塞队列。此队列按照FIFO排列元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。 SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到一个线程调用移出操作，否则一个插入操作一直处于阻塞状态，吞吐量通常高于LinkedBlockingQueue，静态工厂Executors.newCachedThreadPool使用了这个队列。 PriorityBlockingQueue：一个具有优先级的无界阻塞队列。 maximumPoolSize（线程池的最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已经创建的线程数小于最大线程数，则线程池会在创建新的线程执行任务。值得注意的是，如果使用了无界的阻塞队列这个参数就没有任何意义。 ThreadFactory：用于设置创建线程的工厂，可以通过这个线程工厂给每个创建出来的线程设置更有意义的名字。 RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认的情况是AbortPolicy，表示无法处理新任务时抛出的异常。在JDK中提供了以下4中策略。 AbortPolicy：抛出异常。 CallerRunsPolicy：只用调用者所在线程来运行任务。 DiscardOldestPolicy：丢弃任务队列里面最近的一个任务，并执行当前的任务。 DiscardPolicy: 不处理，丢弃掉。当然也可以根据应用场景来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化存储不能处理的任务。 keepAliveTime（线程活动保持时间）：线程池的工作空闲后，保持存货时间。所以，如果任务很多，并且每个任务执行很短，则可以调大时间，提交线程的利用率。这个线程活动保持时间指定不是核心线程，而是除了核心线程外的线程。核心线程一般会一直存货。 TimeUnit（线程活动保持时间的单位）。 向线程池提交任务可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。 execute()方法用与提交不需要返回值的任务，所以无法判断是否被线程执行成功。通过下一代码可知execute()方法输入的任务是一个Runnable的实例。 123456threadPool.execute(new Runnable() &#123; @Override public void run() &#123; // TODO &#125;&#125;); submit()方法用于提交需要返回值的任务。线程池会返回一个Future类型的对象，通过这个Future对象可以判断任务是否执行完成，而使用get(long timeout, TimeUnit unit)方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。 123456789Future&lt;String&gt; future = executorService.submit(new MyCallable());log.info("do something in main");Thread.sleep(1000);String s = null;try &#123; s = future.get(1, TimeUnit.SECONDS);&#125; catch (TimeoutException e) &#123; e.printStackTrace();&#125; 关闭线程池可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池，它们的原理是遍历池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务将永远无法终止。但是它们有一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停执行任务的线程，并返回等待任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。 只要调用了着两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已经关闭后，才表示线程池关闭成功，这时调用isTermined方法就会返回true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。 合理配置线程池想要合理配置线程池，就必须要分析任务特性，可以从以下几个角度来分析。 任务性质：CPU密集性、IO密集型和混合任务。 任务的优先级：高、中、低。 任务的执行时间：长、中、短。 任务的依赖性：是否依赖其他系统资源，如数据库连接。 性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务应该配置尽可能小的线程，如配置 $N_{cpu}+1$个线程的线程池。由于IO密集型任务线程并不是一直执行任务，则应配置尽可能多的线程。如 $2*N_{cpu}$。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型和IO密集型任务，这要这两个任务执行时间相差不是太大，则没有必要进行分解。可以通过Runtime.getRuntime().availableProcessor()方法获取当前设备的CPU数量。 优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。他可以让优先级高的任务先执行。 注意：如果一直有高优先级的任务提交到队列里，那么优先级低的任务可能永远不能执行。 执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先队列，让线程执行短的任务先执行。 依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，等待的时间越长，则CPU空闲时间也就越长，那么线程数就应该设置的越大，这样才能更好的利用CPU。 建议使用有界队列。有界队列能增加系统的稳定性和预警能力，可以根据需要设置大一点儿，比如几千。因为无界队列的容量是无限的可能任务一多可能会出现OOM的异常。 线程池监控如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，可以根据线程池的使用状况快速定位问题。可以通过线程池提交的参数进行监控，在监控线程池的时候可以使用以下属性。 taskCount：线程池需要执行的任务数量。 completedTaskCount：线程池在运行刚欧城中已完成的任务数量，小于或等于taskCount。 largestPoolSize：线程池里曾经创建过的最大的线程数量。通过这个数据就可以知道线程池是否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。 getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池中的线程不会自动销毁，所以这个大小只增不减。 getActivityCount：获取活动的线程数。 通过扩展线程池进行监控。可以通过继承线程池来自定义线程池，重写线程池的beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执行一些代码来进行监控。例如，线程任务的平均执行时间、最大执行时间和最小关闭时间等。这几个方法在线程池里是空方法。 1protected void beforeExecute(Thread t, Runnable r) &#123; &#125;]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>JUC</tag>
        <tag>线程池</tag>
        <tag>Executor</tag>
        <tag>ThreadPoolExecutor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的阻塞队列]]></title>
    <url>%2F2019%2F04%2F14%2FJava%E4%B8%AD%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[Java中的阻塞队列阻塞队列（Blocking Queue）是一个支持两个附加操作的队列。这两个附加操作支持阻塞的插入和移除方法。 支持阻塞的插入方法，意思是当队列满时，队列会阻塞插入元素的线程，知道队列不满。 支持阻塞移出的方法：意思是在队列为空时，获取元素的线程对等待队列变为非空。 阻塞队列常用于生产者消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。 在阻塞队列不可用时，这两个附加操作提供了四种处理方式： 方法/处理方式 抛出方式 返回特殊值 一直阻塞 超时退出 插入方法 add(e) offer(e) put(e) offer(e, time, unit) 移出方法 remove() poll() take() put(time, out) 检查方法 element() peek() 不可用 不可用 不可用 抛出异常：当队列满时，如果再往队列里面插入元素，就会抛出IllegalStateException(&quot;Queue full&quot;)异常。当队列空时，从队列中获取元素会抛出NoSuchElementException异常。 返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移出方法，则是从队列里取出一个元素，如果没有则返回null。 一直阻塞：当阻塞队列满时，如果生产者线程往队列里面put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列为空时，如果消费者从队列里面take元素，队列会阻塞住消费者线程，直到队列不为空。 注意：如果是无界阻塞队列，队列不可能会出现满了的情况，所以使用put和offer方法永远不会被阻塞，而是使用offer方法时，该方法永远返回true。 阻塞队列对应 123456789101112131415161718192021222324252627282930313233343536public interface BlockingQueue&lt;E&gt; extends Queue&lt;E&gt; &#123; // 抛出异常 boolean add(E e); // 返回特殊值 boolean offer(E e); // 阻塞，可中断 void put(E e) throws InterruptedException; // 超时退出 boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException; // 阻塞，可中断 E take() throws InterruptedException; // 返回特殊值，也就是删除的对象 E poll(long timeout, TimeUnit unit) throws InterruptedException; // 剩余的容量 int remainingCapacity(); // 删除 抛出异常 boolean remove(Object o); // 是否包含 public boolean contains(Object o); // 从该队列中删除可用元素，并将它们添加到给定集合中。 int drainTo(Collection&lt;? super E&gt; c); // 从该队列中删除maxElements可用元素，并将它们添加到给定集合中。 int drainTo(Collection&lt;? super E&gt; c, int maxElements);&#125; Java里的阻塞队列JDK提供了7个阻塞队列，如下： ArrayBlockingQueue：一个由数组构成的有界阻塞队列。 LinkedBlockingQueue：一个由链表组成的有界阻塞队列。 PriorityBlockingQueue：一个支持优先级排列的无界阻塞队列。 DelayQueue：一个使用优先级队列实现的无界阻塞队列。 SynchronousQueue：一个不存储元素的阻塞队列。 LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。 LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。 1. ArrayBlockingQueueArrayBlockingQueue是一个数组实现的有界队列。此队列按照先进先出（FIFO）的原则对元素进行排序。 下面的是一个ArrayBlockingQueue的一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Slf4jpublic class ArrayBlockingQueueExample &#123; private static ArrayBlockingQueue&lt;Integer&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(10); public static void main(String[] args) throws InterruptedException &#123; // 放入10个元素 for (int i = 0; i &lt; 10; i++) &#123; log.info("往阻塞队列中放入：&#123;&#125;", i); blockingQueue.put(i); &#125; if (blockingQueue.remainingCapacity() &gt; 0) &#123; log.info("阻塞队列中没有空间了"); &#125; else &#123; log.info("阻塞队列中的剩余空间：&#123;&#125;", blockingQueue.remainingCapacity()); &#125; new Thread(() -&gt; &#123; try &#123; Thread.sleep(5000); Integer take = blockingQueue.take(); log.info("从阻塞队列中取出一个数据：&#123;&#125;", take); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); log.info("往阻塞队列插入一个数据"); try &#123; blockingQueue.add(11); &#125; catch (IllegalStateException e) &#123; log.info("往阻塞队列中插入（add）数据的时候发生异常：&#123;&#125;", e); &#125; boolean offer = blockingQueue.offer(11); log.info("往阻塞队列中插入(offer)数据的时候，返回一个特殊值，&#123;&#125;", offer); log.info("往阻塞队列中插入(put)数据的时候，一直阻塞"); blockingQueue.put(11); for (int i = 0; i &lt; 10; i++) &#123; Integer take = blockingQueue.take(); log.info("从阻塞队列中取出一个元素：&#123;&#125;", take); &#125; &#125;&#125; 默认情况下不保证线程公平的访问队列，所谓公平访问是指阻塞的线程，可以按照队列阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对等待的线程是非公平的，如果有一个线程刚好在队列可用的时候调用了take()方法，那么可能调用take()方法的线程会插队到等待队列中的第一个节点的前面。为了保证公平性，通常会降低吞吐量。我们可以使用一下代码创建一个非公平的阻塞队列。 1ArrayBlockingQueue&lt;Integer&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(10, true); 访问者的公平锁是通过可重入锁实现的，代码如下： 12345678public ArrayBlockingQueue(int capacity, boolean fair) &#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.items = new Object[capacity]; lock = new ReentrantLock(fair); notEmpty = lock.newCondition(); notFull = lock.newCondition();&#125; 可以看到ArrayBlockingQueue是通过ReentrantLock可重入锁和这个可重入锁的两个等待的Condition队列，notEmpty和notFull实现的。 下面来看看它的put和take方法的源码： 1234567891011121314151617181920212223242526public void put(E e) throws InterruptedException &#123; Objects.requireNonNull(e); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; // 队列满了的时候进入notFull等待队列 while (count == items.length) notFull.await(); enqueue(e); &#125; finally &#123; lock.unlock(); &#125;&#125;public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; // 队列为空的时候进入notEmpty等待队列 while (count == 0) notEmpty.await(); return dequeue(); &#125; finally &#123; lock.unlock(); &#125;&#125; 2. LinkedBlockingQueueLinkedBlockingQueue是一个基于链表的实现的有界队列。此队列的默认最大长度为Integer.MAX_VALUE。此队列按照先进先出的顺序对元素进行排序。 LinkedBlockingQueue的示例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Slf4jpublic class LinkedBlockingQueueExample &#123; private static LinkedBlockingQueue&lt;Integer&gt; blockingQueue = new LinkedBlockingQueue&lt;&gt;(10); public static void main(String[] args) throws InterruptedException &#123; // 放入10个元素 for (int i = 0; i &lt; 10; i++) &#123; log.info("往阻塞队列中放入：&#123;&#125;", i); blockingQueue.put(i); &#125; if (blockingQueue.remainingCapacity() &gt; 0) &#123; log.info("阻塞队列中没有空间了"); &#125; else &#123; log.info("阻塞队列中的剩余空间：&#123;&#125;", blockingQueue.remainingCapacity()); &#125; new Thread(() -&gt; &#123; try &#123; Thread.sleep(5000); Integer take = blockingQueue.take(); log.info("从阻塞队列中取出一个数据：&#123;&#125;", take); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); log.info("往阻塞队列插入一个数据"); try &#123; blockingQueue.add(11); &#125; catch (IllegalStateException e) &#123; log.info("往阻塞队列中插入（add）数据的时候发生异常：&#123;&#125;", e); &#125; boolean offer = blockingQueue.offer(11); log.info("往阻塞队列中插入(offer)数据的时候，返回一个特殊值，&#123;&#125;", offer); log.info("往阻塞队列中插入(put)数据的时候，一直阻塞"); blockingQueue.put(11); for (int i = 0; i &lt; 10; i++) &#123; Integer take = blockingQueue.take(); log.info("从阻塞队列中取出一个元素：&#123;&#125;", take); &#125; &#125;&#125; LinkedBlockingQueue是通过两个ReentrantLock，以及这两个ReentrantLock的等待队列Condition，以及一个AtomicInteger实现的。 1234567891011121314/** Current number of elements */private final AtomicInteger count = new AtomicInteger();/** Lock held by take, poll, etc */private final ReentrantLock takeLock = new ReentrantLock();/** Wait queue for waiting takes */private final Condition notEmpty = takeLock.newCondition();/** Lock held by put, offer, etc */private final ReentrantLock putLock = new ReentrantLock();/** Wait queue for waiting puts */private final Condition notFull = putLock.newCondition(); 下面我们来看看它的具体的put方法和take方法的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public void put(E e) throws InterruptedException &#123; if (e == null) throw new NullPointerException(); final int c; final Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; putLock.lockInterruptibly(); try &#123; while (count.get() == capacity) &#123; notFull.await(); &#125; enqueue(node); c = count.getAndIncrement(); if (c + 1 &lt; capacity) notFull.signal(); &#125; finally &#123; putLock.unlock(); &#125; // 如果c == 0唤醒notEmpty等待队列上等待的线程。 if (c == 0) signalNotEmpty();&#125;private void signalNotEmpty() &#123; final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try &#123; notEmpty.signal(); &#125; finally &#123; takeLock.unlock(); &#125;&#125;public E take() throws InterruptedException &#123; final E x; final int c; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; takeLock.lockInterruptibly(); try &#123; while (count.get() == 0) &#123; notEmpty.await(); &#125; x = dequeue(); c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); &#125; finally &#123; takeLock.unlock(); &#125; if (c == capacity) signalNotFull(); return x;&#125; 可以看到这里使用了两个锁，一个用于生产一个消费，因为生产在链表的一端，而消费在链表的另一端，操作互不影响。 3. PriorityBlockingQueuePriorityBlockingQueue是一个支持优先级的无界阻塞队列，默认情况下采用自然顺序升序排列。也可以自定义类实现Comparable接口来指定元素的排序规则。或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。 优先队列因为是无界的，所以不会出现元素已经满了的情况，只会出现元素空了的情况，所以优先队列的实现只用了一个ReentrantLock和它的等待队列notEmpty。 12345private final ReentrantLock lock = new ReentrantLock();/** * Condition for blocking when empty. */private final Condition notEmpty = lock.newCondition(); 具体在插入和删除的时候用到了优先队列，也就是堆排序的思想。在这里不做讨论。 4. DelayQueueDelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建的时候才可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。 DelayQueue非常有用，可以将DelayQueue运用在如下的场景。 缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程来循环查询DelayQueue，一旦能从DelayQueue获取元素，表示缓存有效期到了。 定时任务调度：使用DelayQueue保存当天将会执行的任务和时间，一旦从DelayQueue中获取到任务就开始执行，比如TimerQueue就是使用DelayQueue实现的。 1. 如何实现Delay接口DelayQueue队列的元素必须实现Delay接口。我们可以参考ScheduledThreadPoolExecutor里的ScheduleFutureTask类的实现，一共有三步。 第一步：在创建对象的时候，初始化基本数据。使用time记录当前对象延迟到什么时候可以使用，使用sequenceNumber标识元素在队列中的先后顺序。如下代码所示。 123456789101112/** Sequence number to break ties FIFO */private final long sequenceNumber;/** The nanoTime-based time when the task is enabled to execute. */private volatile long time;ScheduledFutureTask(Runnable r, V result, long triggerTime, long sequenceNumber) &#123; super(r, result); this.time = triggerTime; this.period = 0; this.sequenceNumber = sequenceNumber;&#125; 第二步：实现getDelay方法，该方法返回当前元素还需要延时多长时间，单位是纳秒，代码如下。 123public long getDelay(TimeUnit unit) &#123; return unit.convert(time - System.nanoTime(), NANOSECONDS);&#125; 这里的延时时间triggerTime为纳秒，自己设计的时候最好使用纳秒，因为实现getDelay()方法时可以指定任意单位，一旦以秒作为单位，而延时时间又精确不到纳秒就麻烦了。使用时请注意当time小于当前时间单位的时，getDelay会返回负数。 第三步：实现compareTo方法来指定元素的顺序。例如，让延时时间最长的放在队列的末尾。实现代码如下。 123456789101112131415161718public int compareTo(Delayed other) &#123; if (other == this) // compare zero if same object return 0; if (other instanceof ScheduledFutureTask) &#123; ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other; long diff = time - x.time; if (diff &lt; 0) return -1; else if (diff &gt; 0) return 1; else if (sequenceNumber &lt; x.sequenceNumber) return -1; else return 1; &#125; long diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS); return (diff &lt; 0) ? -1 : (diff &gt; 0) ? 1 : 0;&#125; 2. 如何实现延时阻塞队列延时阻塞队列的实现非常简单，当消费者从队列里面去元素的时候，如果没有元素达到延时时间，就阻塞当前线程。 123456789101112131415161718192021222324252627282930313233public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; for (;;) &#123; E first = q.peek(); if (first == null) available.await(); else &#123; long delay = first.getDelay(NANOSECONDS); if (delay &lt;= 0L) return q.poll(); first = null; // don't retain ref while waiting if (leader != null) available.await(); else &#123; Thread thisThread = Thread.currentThread(); leader = thisThread; try &#123; available.awaitNanos(delay); &#125; finally &#123; if (leader == thisThread) leader = null; &#125; &#125; &#125; &#125; &#125; finally &#123; if (leader == null &amp;&amp; q.peek() != null) available.signal(); lock.unlock(); &#125;&#125; 代码中的变量leader是一个等待获取队列头部元素的线程。如果leader不等于空，表示已经有线程在等待获取队列的头元素。所以，使用await()方法让当前线程等待信号。如果leader等于空，则把当前线程设置成leader，并使用awaitNanos()方法让当前线程接收信号或等待delay时间。 一个简单的DelayQueue的demo。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Slf4jpublic class DelayQueueExample &#123; static class MyDelayedClass implements Delayed &#123; private long time; private int value; public MyDelayedClass(long time, int value) &#123; this.time = System.nanoTime() + time; this.value = value; &#125; @Override public long getDelay(TimeUnit unit) &#123; return unit.convert(time - System.nanoTime(), TimeUnit.NANOSECONDS); &#125; @Override public int compareTo(Delayed o) &#123; if (o == this) &#123; return 0; &#125; if (o instanceof MyDelayedClass) &#123; MyDelayedClass x = (MyDelayedClass) o; long diff = time - x.time; if (diff &lt; 0) &#123; return -1; &#125; else if (diff &gt; 0) &#123; return 1; &#125; else &#123; return 0; &#125; &#125; long diff = getDelay(TimeUnit.NANOSECONDS) - o.getDelay(TimeUnit.NANOSECONDS); return (diff &lt; 0) ? -1 : (diff &gt; 0) ? 1 : 0; &#125; &#125; private static DelayQueue&lt;MyDelayedClass&gt; delayQueue = new DelayQueue&lt;&gt;(); public static void main(String[] args) throws InterruptedException &#123; for (int i = 0; i &lt; 10; i++) &#123; delayQueue.put(new MyDelayedClass(TimeUnit.NANOSECONDS.convert((i + 1) * 10, TimeUnit.SECONDS), i)); &#125; for (int i = 0; i &lt; 10; i++) &#123; log.info("从DelayQueue中获取元素，时间为：&#123;&#125;", new Date()); MyDelayedClass take = delayQueue.take(); log.info("从DelayQueue中获取元素成功，时间为：&#123;&#125;", new Date()); &#125; &#125;&#125; 5. SynchronousQueueSynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。 它支持公平访问队列。默认情况下采用非公平性策略访问队列。使用如下构造器可以创建一个公平访问的SynchronousQueue，如果设置为true，则等待的线程会采用先进先出的顺序访问队列。 123public SynchronousQueue(boolean fair) &#123; transferer = fair ? new TransferQueue&lt;E&gt;() : new TransferStack&lt;E&gt;();&#125; SynchronousQueue可以看成一个传球手，负责把生产的线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。 6. LinkedTransferQueueLinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedQueue多了tryTransfer和transfer方法。 transfer方法 如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素放在队列的tail节点，并等待该元素被消费者消费才返回。 tryTransfer方法 tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则直接返回flase。和transfer方法的区别是tryTransfer方法无论是消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。 对于带有时间限制的tryTransfer(E e, long timeout, TimeUnit unit)方法，试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间在返回，如果超时还没有消费，则返回false，如果在超时时间内消费了该元素，则返回true。 7. LinkedBlockingDequeueLinkedBlockingDequeue是一个由链表结构组成的双向阻塞队列。所谓双向阻塞队列。所谓双向阻塞队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque多了addFirst、addLast、offerLast、peekFirst、peekLast等方法，以First单词结尾的方法，表示插入、获取或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素，另外，插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst。 在初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在工作窃取模式中。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>队列</tag>
        <tag>阻塞队列</tag>
        <tag>BlockingQueue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里养猪]]></title>
    <url>%2F2019%2F04%2F12%2F%E9%98%BF%E9%87%8C%E5%85%BB%E7%8C%AA%2F</url>
    <content type="text"><![CDATA[阿里养猪题目小明是一个数学家，他喜欢用数字给事物命名编号，他给自己编号为1，同时在2019年小明开办了一个农场，准备开始养母猪，他专门给农场的母猪用以下数列2，3，4，5，7，9，12，16，21，28，37，49，65，86，114，151…进行命名。假设农场的母猪永远不会死，小母猪出生后3年后成熟，成熟后从第三年开始每年只会生一只小母猪。第一年农场，有一只刚刚出生的小母猪和一只成熟的母猪(本年不再生小猪，下一年开始生小猪)，并给他们编号为2和3。请问，第m只母猪编号为多少？其是哪一年出生的？小明还准备了1份礼物，专门颁给农场第1到m只的母猪颁奖，颁奖规则如下:选出第1到m只的母猪翻转编号(114编号翻转为411)为第k大的母猪进行颁奖，请问是第几只猪获奖？提示: f(n)=f(n-2)+f(n-3)。 12345678910输入:输入两个参数半角逗号分隔m,k输出:输出三个数字半角逗号分隔第m只母猪编号,哪一年出生,第几只小猪获奖输入范例:20,3输出范例:465,2024,15 我的答案。没测过。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class YangPig &#123; static class Pair implements Comparable&lt;Pair&gt; &#123; public int index; public int value; @Override public int compareTo(Pair o) &#123; return o.value - this.value; &#125; &#125; static String calculate(int m, int k)&#123; String res = ""; int[] array = new int[m]; array[0] = 2; array[1] = 3; array[2] = 4; for (int i = 3; i &lt; m; i++) &#123; array[i] = array[i - 2] + array[i - 3]; &#125; res += array[m - 1] + "."; int a = 2; int b = 3; int year = 2020; while (true) &#123; if (b &gt;= m) &#123; break; &#125; int tmp = b; b = a + b; a = tmp; year++; &#125; res += year + "."; for (int i = 0; i &lt; m; i++) &#123; array[i] = reverse(array[i]); &#125; Pair[] pairs = new Pair[m]; for (int i = 0; i &lt; m; i++) &#123; pairs[i] = new Pair(); pairs[i].index = i; pairs[i].value = array[i]; &#125; Arrays.sort(pairs); res += ++pairs[k - 1].index; return res; &#125; static int reverse(int n) &#123; int res = 0; while (n != 0) &#123; res *= 10; res += n % 10; n /= 10; &#125; return res; &#125; public static void main(String[] args) &#123; System.out.println(calculate(20, 3)); &#125;&#125; 思路第一个问题：求序号，不用说，比较好求。 第二个问题：求第m个猪是第几年出生的。题目中成熟后从第三年开始每年只会生一只小母猪。这个问题和斐波那契的那个问题很像，斐波那契问题中是兔子三个月后就成熟了，可以生兔子了，而这里的是猪。第一年2，第二年3个，第三年5个，递推公式是f(n) = f(n - 1) + f(n - 2)。 第三个问题：求编号反转后的第k大的，先反转，这个也很简单。但是这里有一个问题是第k大的猪，首先能想到的是排序，但是排序后有一个问题就是反转后的编号在数组中的位置变了，而题目的要求是反转后编号第k大猪，所以这里的需要记录在数组中出现的序号。]]></content>
      <categories>
        <category>笔试</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>养猪</tag>
        <tag>阿里笔试</tag>
        <tag>斐波那契</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AQS源码分析]]></title>
    <url>%2F2019%2F04%2F11%2FAQS%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[AQS源码分析Java并发包的Lock接口的实现基本上都是通过聚合一个同步容器的子类来完成线程控制访问的。 队列同步容器 ： AbstractQueuedSynchronizer队列同步容器（AbstractQueuedSynchronizer），使用来构建其他同步组件的基本框架，它使用了一个int型的成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。 1private volatile int state; 同步容器的主要的工作方式是继承，子类通过继承同步容器并实现它的抽象方法来同步管理状态，在抽象方法实现的过程中避免不了对同步状态的更改，这时就需要使用同步器提供的三个方法（getState()、setState(int newState)和compareAndSetState(int exect, int update)）来进行操作，因为它们是能够保证状态的改变是安全的。子类被推荐定义为自定义同步组件的静态内部类，同步器本身没有实现任何的同步接口，它仅仅定义了若干同步状态的获取和释放方法来供自定义同步组件使用，同步器可以独占的获取同步状态，也可以共享的获取同步状态，这样就方便实现不同类型的同步组件(ReentrantLock、ReentrantReadWriteLock和CountDownLatch等)。 AQS定义资源共享的方式： Exclusive 独占，只有一个线程能执行。 Share 共享，多个线程可以同事执行，如Semaphore和CountDownLatch 同步器是实现锁和其他任意同步组件的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。 对列同步器的接口与示例同步器的设计是基于模板方法的，也就是说，使用者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用着重写的方法。 重写同步器指定的方法时，需要使用同步器提供的如下3个方法来访问或修改同步状态。 getState(): 获取当前同步状态。 getState(int newState):设置当前同步状态。 compareAndSetState(int expect, int update)：使用CAS设置当前状态，该方法能够保证设置状态的原子性。 同步器可以重写的方法如下： 方法名称 描述 protected boolean tryAcquire(int arg) 独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期。然后在进行CAS设置同步状态 protected boolean tryRelease(int arg) 独占方式释放同步状态，等待获取同步的线程将有机会获取同步状态 protected int tryAcquireShared(int arg) 共享获取同步状态，返回值大于等于0的值，表示获取成功，反之获取失败 protected boolean tryReleaseShared(int arg) 共享释放同步状态 protected boolean isHeldExeclusively() 当前线程是否在独占模式下被线程占用，一般该方法表示是否被当前线程所占用 实现自定义同步组件时，会调用同步器提供的模板方法，这些模板方法如下：|方法名称|描述||:—|:—||void acquire|独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步对列等待，该方法将会调用重写的tryAcquire(int arg)方法||void acquireInterruptibly(int arg)|与acquire(int arg)方法相同，但是个该方法可以响应中断，当前线程为获取同步状态而进入同步对列中，如果当前线程被中断，该方法会抛出InterruptedException并返回||boolean tryAcquireNanos(int arg, long nanos)|在acquireInterruptibly(int arg)基础上增加了超时限制当前线程在规定的时间内没有获取同步状态，那么将返回false，如果获取到了返回true||void acquireShared(int arg)|共享的方式获取同步状态，如果当前线程未获取到同步状态，将会进入同步对列等待，与独占的方式获取的主要区别是在同一时刻可以有多个线程获取到同步状态||void acquireSharedInterruptibly(int arg, long nanos)|与acquireShared()方法相同，该方法响应中断||boolean tryAcquireSharedNanos(int arg, int nanos)|在acquireSharedInterruptibly(int arg)基础上增加了超时限制||boolean release(int arg)|独占的方式释放同步状态，该方法会在释放同步状态之后，将同步状态的第一个节点包含的线程唤醒||boolean releaseShared(int arg)|共享的方式释放同步状态||Collection getQueuedThreads()|获取等待在同步队列上的线程集合|同步器上提供的模板方法基本上有三类： 独占的方式获取与释放同步状态; 共享的方式获取与方式同步状态; 查询同步队列中的线程等待情况。 以ReentrantLock为例,state初始化为0，表示为锁定状态，A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其它线程再tryAcquire()是就会失败，直到A线程unLock()，state=0(即释放锁)，其它线程才有机会获取该锁，当然，释放锁之前，A线程自己是可以重复获取此锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这也就是可重入。 队列同步器的实现分析同步队列同步器依赖与一个队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态的信息构造成一个节点(Node)并将其加入同步队列，同时会吧当前线程阻塞，当同步状态释放时，会把首节点中的线程唤醒，使其再次获取同步状态。) 123456789101112131415161718192021static final class Node &#123; static final Node SHARED = new Node(); static final Node EXCLUSIVE = null; /** waitStatus value to indicate thread has cancelled */ static final int CANCELLED = 1; /** waitStatus value to indicate successor's thread needs unparking */ static final int SIGNAL = -1; /** waitStatus value to indicate thread is waiting on condition */ static final int CONDITION = -2; /** * waitStatus value to indicate the next acquireShared should * unconditionally propagate */ static final int PROPAGATE = -3; volatile int waitStatus; volatile Node prev; volatile Node next; volatile Thread thread; Node nextWaiter;&#125; 下面的是节点的属性与名称及描述 int waitStatus等待的状态，包含如下： CANCELLED，值为1，由于同步队列中的等待的线程等待超时或者被中断，需要中同步队列中取消等待，节点进入该状态将不会变化。 SIGNAL，值为-1，后继节点的线程处于等待状态，当前节点如果释放了同步状态或者被取消，将会通知该节点，使得后继节点得以运行。 CONDITION，值为-2，节点在等待队列中，节点线程等待在Condition上，当其它线程对Condition调用了signal()方法后，该节点将会从等待队列中转移到同步队列中，加入到对同步状态的获取中。 PROPAGATE，值为-3，状态需要向后传播，表示releaseShared需要被传播给后续节点，仅在共享锁模式下使用。 INITIAL，值为0，初始状态。 Node prev: 前驱节点，当节点加入同步队列时被设置（尾部添加） Node next: 后继节点。 Node nextWaiter:等待队列中的后继节点。如果当前节点是共享的，那么这个字段将是一个SHARED常量，也就是说节点类型（独占和共享）和等待队列中的后继节点公用一个字段。 Thread thread：获取同步状态的线程。 Node是过程同步队列的基础，同步器拥有head和tail，获取同步状态失败的线程将会成为节点加入该队列的尾部。这里加入队列的过程必须要保证线程安全，因此同步器是一个基于CAS的设置节点的方法：compareAndSendTail(Node expect, Node update)，它需要传递当前线程“认为”的尾节点，只有设置成功，当前节点才正式与尾节点建立关联。 同步队列遵循FIFO，首节点是获取同步状态成功的节点，首节点在释放同步状态时，会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。 123private final boolean compareAndSetTail(Node expect, Node update) &#123; return unsafe.compareAndSwapObject(this, tailOffset, expect, update);&#125; 设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功的获取到同步状态，因此设置头结点的方法并不需要使用CAS来保证，它只需要将首节点设置成原首节点的后继节点并断开首节点与next引用即可。 2. 独占式同步状态获取和释放通过AQS的acquire(int arg)方法可以获取同步状态，该方法不响应中断，也就是说，由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移出。 这个方法是线程来获取共享资源的入口，如果获取到资源，方法直接返回，来来来否则进入等待队列，直到获取到资源为止。 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 上面的代码主要完成了同步状态获取、节点构造、加入同步队列以及同步队列中自旋等待的相关工作，其流程如下： 通过tryAcquire()方法尝试获取锁，这个方法需要实现类自己实现获取锁的逻辑，获取锁成功后则不执行后面的加入等待队列的逻辑。 如果尝试获取锁失败后，调用addWaiter() 方法将当前线程封装成一个Node对象，并加入队列的尾部。其中： Node.EXCLUSIVE 表示独占是获取同步状态。 Node.SHARED 表示共享式获取同步状态 acquireQueued() 调用这个方法使的该节点以“死循环”的方式获取同步状态，如果获取不到则阻塞节点中的线程，而被阻塞的线程的唤醒主要依靠前去节点出队或阻塞线程被中断来实现。 1. tryAcquire(int arg)方法这个方法的源码如下： 123protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException();&#125; 正如前面提到的这是一个需要子类实现的方法。这个方法的方法体内只是抛出了一个异常，一般当不支持请求操作时，抛出该异常。 2. addWaiter(Node mode)方法此方法的作用是将当前的线程构造成一个节点，然后添加进队列中，并返回当前线程所在节点。 1234567891011121314151617181920212223242526private Node addWaiter(Node mode) &#123; /** * Node有两种模式 * - EXCLUSIVE 独占 * - SHARED 共享 * 创建一个基于当前线程的节点，该节点是Node.EXCLUSIVE */ Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure // 快速尝试 Node pred = tail; // 这里判断队尾是不是为空，如果不为空则直接将节点加入队尾 if (pred != null) &#123; node.prev = pred; // 采取CAS操作，将当前节点设置为队尾节点，由于采用了CAS原子操作，无论怎么修改，都有且只有一条线程可以修改成功，其余都将执行后面的enq方法 if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; // 如果失败则通过enq入队 enq(node); return node;&#125; 简单来说addWaiter(Node mode)方法做了两件事情： 创建基于当前线程的独占类型的节点。 将节点加入队尾。 123456789101112131415161718private Node enq(final Node node) &#123; // CAS"自旋"，直到成功入队 for (;;) &#123; Node t = tail; // 队列为空，创建一个空的标志节点作为head节点，并将tail也指向它 if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; // 正常入队 node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 这是一个CAS自旋的用法。如果compareAndSetHead或compareAndSetTail()返回false，那么就说明有其他线程修改了head或tail，然后进入下一个循环继续。 3. acquireQueued(final Node node, int arg)方法获取资源失败后，获取资源的线程被添加进入队列后，下一步的做法就是进入等待状态，直到其它线程彻底释放资源后唤醒自己。 这里需要说明一点的是，head节点代表当前持有锁的线程，那么如果当前节点的pred节点是head节点，很可能此时head节点已经释放锁了，所以此时需要再次尝试获取锁。 123456789101112131415161718192021222324252627282930313233final boolean acquireQueued(final Node node, int arg) &#123; // 这个变量使用来标记是否成功获取到资源，也就是是否成功获取到锁 boolean failed = true; try &#123; // 标记等待过程中是否可以被中断 boolean interrupted = false; // 下面的是一个CAS自旋 for (;;) &#123; // 获取前驱节点 final Node p = node.predecessor(); // 如果p是队列的首节点并且能够获取到资源 // 如果当前节点的前驱节点是头节点，那么当前节点（线程）就有机会获取锁了 if (p == head &amp;&amp; tryAcquire(arg)) &#123; // 拿到资源（获取到锁）后，将当前节点设置为首节点 setHead(node); // 然后将前驱节点的next设置为空，有助于垃圾回收器回收 p.next = null; // help GC // 成功获取 failed = false; // 等待的过程被中断了 return interrupted; &#125; // 检查是否可以等待 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) // 如果等待过程中被中断过，那么就将interrupted标记为true interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 这一步acquireQueued(final Node node, int arg)方法主要做了以下事情： 判断当前节点的前驱节点pred是否是head节点，如果是，尝试获取锁； 获取失败后，进入挂起逻辑。 12345678910/** * Node类中的一个方法，获取当前节点的前驱节点 */final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p;&#125; 12345678/** * 设置首节点为node */private void setHead(Node node) &#123; head = node; node.thread = null; node.prev = null;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 这个方法主要是检查状态，查看是否可以等待 */private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; // 拿到前驱节点的状态 int ws = pred.waitStatus; // 如果前驱节点的状态为SIGNAL，那么就可以进行等待，因为当前驱节点的waitStatus是Node.SIGNAL，那么释放同步锁的时候，会唤醒后继节点 if (ws == Node.SIGNAL) /* * This node has already set status asking a release * to signal it, so it can safely park. */ return true; if (ws &gt; 0) &#123; /* * 如果前驱节点放弃了对锁的持有(放弃获取同步状态了)，那么就一直往前找，直到找到一个没有放弃获取同步状态的节点，然后插在它的后面 * 也就是说当当前节点的前驱节点是CANCELLED，需要从队列中删除 * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ do &#123; // pred = pred.prev // node.prev = pred node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; /* * 如果前驱节点是其他状态，那么就把前驱节点的状态设置成SIGNAL，然后进可以进行等待了 * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don't park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125;private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted();&#125; 这一步houldParkAfterFailedAcquire(Node pred, Node node)方法主要做了以下事情： 判断pred节点状态，如果尾SIGNAL，则返回true执行挂起。 删除状态为CANCELLED的节点。 下面的是acquire(int arg)方法的大致流程： 独占式释放资源在获取同步状态并执行响应的逻辑后，就需要释放同步状态，使得后续的节点能够继续获取同步状态。通过调用同步器的release(int arg)方法可以释放同步状态，该方法在释放同步状态后，会唤醒其后继节点，进而使后继节点获取同步状态。源码如下： 123456789101112131415161718192021222324252627282930313233343536public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125;/** * 和tryAcquire()方法一样都是需要子类实现的 */protected boolean tryRelease(int arg) &#123; throw new UnsupportedOperationException();&#125;private void unparkSuccessor(Node node) &#123; // node一般为当前线程所在的节点 int ws = node.waitStatus; // 将当前的线程状态设置为0 if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); // 找到下一个节点 Node s = node.next; // 如果为空或者已经取消 if (s == null || s.waitStatus &gt; 0) &#123; s = null; 从尾部遍历到当前节点，找到最后一个waitStatus &lt;= 0的 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; // 然后唤醒 if (s != null) LockSupport.unpark(s.thread);&#125; 该方法执行时候时，会唤醒后继节点，unparkSuccessor(Node node)方法使用LockSupport来唤醒处于等待状态的线程。中间的过程是寻找一个waitStatus &lt;= 0的节点，当waitStatus &lt;= 0时也就意味着这个节点没有放弃获取同步状态。 3. 共享式获取同步状态和释放共享式获取资源共享式和独占式获取最重要的区别是同一个时刻能否有多个线程同时获取到同步状态。例如读写锁，可以有多个线程获取读的状态，但是只能有一个线程获取写的状态。读写锁就用到了这里的“共享式”。 通过调用同步器的acquireShared(int arg)方法可以共享的获取同步状态，源码如下： 1234public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125; 前面说过tryAcquireShared()这个方法需要子类取实现。如果这个方法返回值小于0代表获取失败，0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以获取。如果获取成功直接返回，如果获取失败则进入doAcquireShared(int arg)，将获取同步状态失败的线程放在同步队列中。下面是doAcquireShared(int arg)的源码： 123456789101112131415161718192021222324252627282930313233343536private void doAcquireShared(int arg) &#123; // 将当前线程通过共享式构造出一个节点（Node）并加入队列尾部 final Node node = addWaiter(Node.SHARED); // 这是一个是否失败的标志 boolean failed = true; try &#123; // 线程是否被中断 boolean interrupted = false; for (;;) &#123; // 获取前驱节点 final Node p = node.predecessor(); // 获取前驱节点是head，这里很有可能是head用完资源后然后将node唤醒 if (p == head) &#123; // 再次尝试获取资源 int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; // 将head指向自己。还有剩余资源时唤醒其他线程 setHeadAndPropagate(node, r); p.next = null; // help GC // 如果等待过程中被中断，此时将node中的线程中断 if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; // 判断自己能否进入等待状态 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 这个和独占式获取很像，不过是将selfInterrupt()放在了上面的这个方法里。这里值得注意的是资源的数量，不独占式获取资源不同的是，独占式永远只有一个线程获取到同步状态，而共享式可以有多个线程获取同步状态，而且有的线程可能在有多个资源时才能获取到。所以这里就有了一个setHeadAndPropagate(Node, int)方法。 123456789101112131415161718192021/** * node指的是当前线程构成的节点 * propagate 是指剩余的资源数 */private void setHeadAndPropagate(Node node, int propagate) &#123; // 记录当前头节点 Node h = head; // Record old head for check below // 设置新的头节点，即把当前获取到锁的节点设置为头节点 // 注意：这里是获取到锁之后的操作，不需要并发控制 setHead(node); // 注意这里有两种情况是需要执行唤醒操作的 // 1. propagate &gt; 0 表示调用方指明了后继节点需要被唤醒 // 2. 头节点后面的节点需要被唤醒（waitStatus），无论是老的头节点还是新的头节点 if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123; Node s = node.next; // 如果当前节点没有后继节点是共享类型或者没有后继节点，则进行唤醒 if (s == null || s.isShared()) doReleaseShared(); &#125;&#125; 在个方法比前面的setHead()方法多了一点就是如果有资源剩余那么就去唤醒下一个的共享线程。其中的doReleaseShared()是释放共享资源的方法，这个会在下面的释放共享资源中说到。 共享式释放资源共享式释放资源使用的是releaseShared(int arg)方法：12345678public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; // 这个方法中会唤醒后继的节点 doReleaseShared(); return true; &#125; return false;&#125; 和独占式释放资源一样，其中的tryReleaseShared(arg)需要子类去实现，如果释放成功会返回true，下面会执行doReleaseShared()方法，这个方法中会尝试唤醒后继节点中的线程，它的源码如下：123456789101112131415161718192021222324private void doReleaseShared() &#123; for (;;) &#123; Node h = head; // 唤醒操作由头节点开始，注意这里的头节点已经是上面重新设置的头节点 // 这里其实是唤醒共享锁节点的后继节点 if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; // 表示后继需要被唤醒 if (ws == Node.SIGNAL) &#123; // CAS 比较失败说明线程已经被唤醒了 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases // 如果CAS比较成功，则使用LockSupport唤醒线程 unparkSuccessor(h); &#125; // 如果后继节点暂时不需要唤醒，则把当前节点的状态设置为PROPAGATE，确保可以传递下去 else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; if (h == head) // head被改变 break; &#125;&#125;]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>异步</tag>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Callable和Future详解]]></title>
    <url>%2F2019%2F04%2F09%2FCallable%E5%92%8CFuture%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Callable和FutureTask详解一般来说，要进行异步计算的时候可以使用Callable和Future或者FutureTask进行。下面我们来探究一下Callable和FutureTask。 Callable和FutureCallable是一个接口，它的源码如下： 12345678910@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; Callable和Runnable之间的区别是：Callable有返回值，并且可以抛出异常，而Runnable不可以。 Callable一般需要和FutureTask或者线程池结合使用。 下面我们来看一下Future接口的源码： 123456789101112131415161718public interface Future&lt;V&gt; &#123; // 取消正在运行的任务 boolean cancel(boolean mayInterruptIfRunning); // 是否取消了 boolean isCancelled(); // 是否结束了 boolean isDone(); // 获取结果，如果任务还没有执行结束，那么就阻塞 V get() throws InterruptedException, ExecutionException; // 限时等待，如果超时就抛出异常 V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; 下面通过两个Demo来演示下FutureTask和线程池与Callable结合使用。 Callable和两个Demo第一个Demo是和线程池结合使用。 123456789101112131415161718192021@Slf4jpublic class FutureDemo &#123; static class MyCallable implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; log.info("do something in callable"); Thread.sleep(5000); return "Done"; &#125; &#125; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; ExecutorService executorService = Executors.newCachedThreadPool(); Future&lt;String&gt; future = executorService.submit(new MyCallable()); log.info("do something in main"); Thread.sleep(1000); log.info("result: " + future.get()); &#125;&#125; 第二个Demo是和FutureTask结合着使用。 12345678910111213141516@Slf4jpublic class FutureTaskDemo &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(() -&gt; &#123; log.info("do something in callable"); Thread.sleep(5000); return "Done"; &#125;); new Thread(futureTask).start(); log.info("do something in main"); String result = futureTask.get(); log.info("result: &#123;&#125;", result); &#125;&#125; 其实，线程池中使用的也是FutureTask来结合Callable使用的。 12345678910public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task); execute(ftask); return ftask;&#125;protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123; return new FutureTask&lt;T&gt;(callable);&#125; 这里的RunnableFuture是一个接口，它即继承了Runnable也继承了Future，它的源码如下： 1234567public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; /** * Sets this Future to the result of its computation * unless it has been cancelled. */ void run();&#125; RunnableFuture中使用了适配器模式，这里的RunnableFuture既可以是Runnable及它的实现类，也可以是Future及它的实现类，在Runnable和Future之间做了适配。 下面来看一下FutureTask中如何实现的Callable异步任务。 FutureTask原理探究FutureTask 封装了一个Callable。 1private Callable&lt;V&gt; callable; FutureTask中定义了Callable的运行中的状态： 123456789private volatile int state;// FutureTask的几种状态private static final int NEW = 0;private static final int COMPLETING = 1;private static final int NORMAL = 2;private static final int EXCEPTIONAL = 3;private static final int CANCELLED = 4;private static final int INTERRUPTING = 5;private static final int INTERRUPTED = 6; 这几种的关系转换如下： 1234NEW -&gt; COMPLETING -&gt; NORMAL // 没有发生异常，也没有被canceledNEW -&gt; COMPLETING -&gt; EXCEPTIONAL // 执行过程中发生异常NEW -&gt; CANCELLED // 执行后被取消NEW -&gt; INTERRUPTING -&gt; INTERRUPTED // INTERRUPTED被中断 FutureTask中封装的返回值： 12/** The result to return or exception to throw from get() */private Object outcome; // non-volatile, protected by state reads/ FutureTask中使用了一个volatile的变量表示callable的运行状态： 12/** The thread running the callable; CASed during run() */private volatile Thread runner; 当有一个线程请求FutureTask最后的返回结果，但是FutureTask中的任务没有完成，那么会把它加入同步等待队列中： 12345678/** Treiber stack of waiting threads */private volatile WaitNode waiters;static final class WaitNode &#123; volatile Thread thread; volatile WaitNode next; WaitNode() &#123; thread = Thread.currentThread(); &#125;&#125; 下面我们来看看FutureTask的构造器： 通过Callable创建一个FutureTask，源码如下： 123456public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable&#125; 通过Runnable和一个result创建一个FutureTask： 1234public FutureTask(Runnable runnable, V result) &#123; this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable&#125; 这里通过`Executors`工具类创建了一个Callable。 下面我们来看看FutureTask的核心源码它的run()方法，它的run()方法，也就是一个Thread类start()之后的会执行的方法。 123456789101112131415161718192021222324252627282930313233343536public void run() &#123; // 如果state不是NEW状态，那么尝试使用CAS把Runner设置为当前线程，如果设置成功，继续执行，如果设置失败，直接返回 if (state != NEW || !RUNNER.compareAndSet(this, null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; // 再次判断 if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; // 调用call result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; // 执行结束，设置结果 if (ran) set(result); &#125; &#125; finally &#123; // runner must be non-null until state is settled to // prevent concurrent calls to run() runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts int s = state; // 重读state，放置中断泄露 if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125;&#125; 需要注意的是catch块中的语句，如果正在运行的线程调用了cancel(true)方法来中断正在执行任务的线程，除非在Callable的call()方法实现上设计成响应中断，否则是不会中断callable.call()方法的执行的。 下面看看上面的方法中调用的几个方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243protected void setException(Throwable t) &#123; // 设置为完成状态 if (STATE.compareAndSet(this, NEW, COMPLETING)) &#123; outcome = t; // 然后设置为EXCEPTIONAL状态 STATE.setRelease(this, EXCEPTIONAL); // final state // 唤醒正在等待的线程 finishCompletion(); &#125;&#125;protected void set(V v) &#123; if (STATE.compareAndSet(this, NEW, COMPLETING)) &#123; outcome = v; // 这里设置称为正常退出的状态 STATE.setRelease(this, NORMAL); // final state finishCompletion(); &#125;&#125;private void finishCompletion() &#123; // assert state &gt; COMPLETING; // 这里通过CAS和LockSupport进行逐个唤醒 for (WaitNode q; (q = waiters) != null;) &#123; if (WAITERS.weakCompareAndSet(this, q, null)) &#123; for (;;) &#123; Thread t = q.thread; if (t != null) &#123; q.thread = null; LockSupport.unpark(t); &#125; WaitNode next = q.next; if (next == null) break; q.next = null; // unlink to help gc q = next; &#125; break; &#125; &#125; done(); callable = null; // to reduce footprint&#125; 下面来看看FutureTask的get()方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public V get() throws InterruptedException, ExecutionException &#123; int s = state; // 没有完成，则等待完成 if (s &lt;= COMPLETING) s = awaitDone(false, 0L); return report(s);&#125;private int awaitDone(boolean timed, long nanos) throws InterruptedException &#123; // The code below is very delicate, to achieve these goals: // - call nanoTime exactly once for each call to park // - if nanos &lt;= 0L, return promptly without allocation or nanoTime // - if nanos == Long.MIN_VALUE, don't underflow // - if nanos == Long.MAX_VALUE, and nanoTime is non-monotonic // and we suffer a spurious wakeup, we will do no worse than // to park-spin for a while long startTime = 0L; // Special value 0L means not yet parked WaitNode q = null; boolean queued = false; for (;;) &#123; int s = state; // 如果任务完成了，则返回 if (s &gt; COMPLETING) &#123; if (q != null) q.thread = null; return s; &#125; // 如果s == COMPLETING，则说明任务已经完成了 else if (s == COMPLETING) // We may have already promised (via isDone) that we are done // so never return empty-handed or throw InterruptedException // 然后进行让步，让这行任务的线程继续执行，因为就差设置outcome的值了 Thread.yield(); else if (Thread.interrupted()) &#123; // 如果线程被中断了，则抛出线程，这里是为了影响中断 removeWaiter(q); throw new InterruptedException(); &#125; else if (q == null) &#123; // 如果队列为空，则直接等待，如果这里timed为false，也就是不需要等待，那么把用当前线程构造一个等待队列的头结点 if (timed &amp;&amp; nanos &lt;= 0L) return s; q = new WaitNode(); &#125; else if (!queued) // 把当前等待线程加入等待队列中 queued = WAITERS.weakCompareAndSet(this, q.next = waiters, q); else if (timed) &#123; final long parkNanos; if (startTime == 0L) &#123; // first time startTime = System.nanoTime(); if (startTime == 0L) startTime = 1L; // 等待时间 parkNanos = nanos; &#125; else &#123; // elapsed 已经等待的时间 long elapsed = System.nanoTime() - startTime; // 已经等待的时间大于等待时间 if (elapsed &gt;= nanos) &#123; 删除这个节点 removeWaiter(q); return state; &#125; parkNanos = nanos - elapsed; &#125; // nanoTime may be slow; recheck before parking // 阻塞 if (state &lt; COMPLETING) LockSupport.parkNanos(this, parkNanos); &#125; else LockSupport.park(this); &#125;&#125;]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java读写锁]]></title>
    <url>%2F2019%2F04%2F08%2FJava%E8%AF%BB%E5%86%99%E9%94%81%2F</url>
    <content type="text"><![CDATA[ReentrantReadWriteLock 分析1. 概述ReentrantReadWriteLock是读写锁，我们一般所说的锁都是排他锁，这些锁在同意时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个线程同时访问，但是在写线程访问的时，所有的读线程和其他的写线程均被阻塞。 读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发相比一般的排他锁有了很大的提升。 除了保证写操作对读操作的可见性以及并发性的提升之外，读写锁能过简化读写交互场景的编程方式。 下面来看ReentrantReadWriteLock的特性 特性 说明 公平性选择 支持非公平（默认）和公平锁获取方式，吞吐量还是非公平优于公平 重进入 该锁支持重进入，以读写线程为例：读线程获取锁之后，能够再次获取读锁。而写线程在获取写锁之后能够再次获取写锁，同时也可以获取读锁 锁降级 遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级称为读锁 2. 读写锁的使用ReadWriteLock仅定义了获取读锁和写锁的两个方法。即readLock()方法和writeLock()方法，而其实现——ReentrantReadWriteLock，除了接口方法之外，还提供了便于外界监控其内部工作状态的方法，这些方法描述如下表： 方法名称 描述 int getReadLockCount() 返回当前锁被获取的次数。该次数不等于获取锁的读线程数，例如，仅一个线程，它连续获取了n次读锁，那么占据读锁的线程数是1，但该方法返回n int getReadHoldCount() 返回当前线程获取读锁的次数。该方法在Java6中加入到ReentrantReadWriteLock中，使用ThreadLocal保存当前线程获取的次数 boolean isWriteLocked() 判断写锁是否被获取 int getWriteHoldCount() 返回当前写锁被获取的次数 接下来，通过一个缓存的实例说明读写锁的使用方式，示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142public class Cache &#123; static Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); static Lock r = rwl.readLock(); static Lock w = rwl.writeLock(); /** * 获取一个key对应的value */ public static final Object get(String key) &#123; r.lock(); try &#123; return map.get(key); &#125; finally &#123; r.unlock(); &#125; &#125; /** * 设置一个key对应的value，并返回就的value */ public static final Object put(String key, Object value) &#123; w.lock(); try &#123; return map.put(key, value); &#125; finally &#123; w.unlock(); &#125; &#125; /** * 清空所有的内容 */ public static final void clear() &#123; w.lock(); try &#123; map.clear(); &#125; finally &#123; w.unlock(); &#125; &#125;&#125; 上述示例中，Cache组合一个非线程安全的HashMap作为缓存的实现，同时使用读写锁的读锁和写锁来保证Cache是线程安全的。在读操作get(String key)方法中，需要获取读锁，这使得并发访问不会被阻塞。写操作put(String key, Object value)方法和clear()方法，在更新HashMap时必须提前获取写锁，当获取写锁后，其他线程对于读锁和写锁的获取均被阻塞，而只有写锁释放之后，其他读锁操作才能继续。Cache使用读写锁提升读操作的并发性，也保证每次读操作对所有写操作的可见性，同时简化了编程。 3. 实现原理分析读写锁的接口： 1234567891011121314public interface ReadWriteLock &#123; /** * Returns the lock used for reading. * * @return the lock used for reading */ Lock readLock(); /** * Returns the lock used for writing. * * @return the lock used for writing */ Lock writeLock();&#125; ReadWriteLock仅有两个方法： readLock(): 获取读锁。 writeLock(): 获取写锁。 1. 读写锁的状态设计读写锁同样依赖自定义同步器实现同步功能，而读写状态就是其同步器的状态。读写锁的自定义的同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态，使得该状态的设计成为读写锁实现的关键。 如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切割成两部分，高16位表示读，低16位表示写，划分方式如图： 当前同步状态表示一个线程已经获取了写锁，且重进入了两次，同时也连续获取了两次读锁读锁。读写锁是如何迅速确定读和写各自的状态呢？答案是通过位运算。假设当前同步状态值为S，写状态等于S&amp;0x0000FFFF(将高16为全部去掉)，读状态等于S&gt;&gt;&gt;16(无符号补0右移16位)。当写状态增加1时，等于S+1，当读状态增加1时，等于S + (1 &lt;&lt; 16)，也就是S + 0x000010000。 根据状态能得出一个推论：S不等于0时，当写状态（S &amp; 0x0000FFFF）等于0，则读状态（S &gt;&gt;&gt; 16）大于0，即读锁已被获取。 2. 写锁的获取与释放写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写锁的状态。如果当前线程在获取写锁时，读锁已被获取（读锁的状态不为0）或着该线程不是已经获取写锁的线程，当前线程进入等待状态，获取写锁的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940protected final boolean tryAcquire(int acquires) &#123; /* * Walkthrough: * 1. If read count nonzero or write count nonzero * and owner is a different thread, fail. * 2. If count would saturate, fail. (This can only * happen if count is already nonzero.) * 3. Otherwise, this thread is eligible for lock if * it is either a reentrant acquire or * queue policy allows it. If so, update state * and set owner. */ // current表示当前线程 Thread current = Thread.currentThread(); // c表示读写锁的状态 int c = getState(); // w表示获取写锁的次数, exclusiveCount(int c)返回的是获取写锁的次数 int w = exclusiveCount(c); // c != 0 表示有线程获取了读锁或者写锁 if (c != 0) &#123; // (Note: if c != 0 and w == 0 then shared count != 0) // 如果读写锁的状态不为0，并且写锁的状态为0，那么肯定读锁的状态不为0 // 存在读锁或者当前线程不是已经获取锁的线程 if (w == 0 || current != getExclusiveOwnerThread()) return false; if (w + exclusiveCount(acquires) &gt; MAX_COUNT) throw new Error("Maximum lock count exceeded"); // Reentrant acquire setState(c + acquires); return true; &#125; // writerShouldBlock() 这里如果是非公平锁直接返回false，如果是公平锁的话，判断前面是否有节点，如果有返回true，如果没有返回flase // writerShouldBlock() 返回true，表示前面有头结点，然后cas尝试获取锁，如果获取成功，则可以进行下面的操作，如果失败，则返回flase。 if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) return false; // 设置当前线程为持有锁的线程 setExclusiveOwnerThread(current); return true;&#125; 该方法除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果读锁存在，则写锁不能被获取，原因在于：读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读线程的后续访问均被阻塞。 写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，同时前次写线程的修改对后续线程可见。 3. 读锁的获取和释放读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问（或者写状态为0）时，读锁总后被成功的获取，而所做的也只有（线程安全的）增加读状态。如果当前线程已获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。 4. 锁降级锁降级指的是写锁降级称为读锁。如果当前线程拥有写锁，然后将其释放，最后在获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指吧当前把持住（当前拥有的）写锁，在获取到读锁，随后释放（先前拥有的）写锁的过程。 接下来看一个锁降级的示例。因为数据不常变化，所以多个线程可能并发地进行数据处理，当数据变更后，如果当前线程感知到数据变化，则进行数据准备工作，同时其他处理线程被阻塞，知道当前线程完成数据准备工作，如下： 123456789101112131415161718192021222324public void processDate() &#123; readLock.lock(); if (!update) &#123; // 必须先释放读锁 readLock.unlokc(); // 锁降级从写锁的获取开始 writeLock.lock(); try &#123; if (!update) &#123; // 准备数据的流程（略） update = true; &#125; readLock.lock(); &#125; finally &#123; writeLock.unlock(); &#125; // 锁降级完成，写锁降级为读锁 &#125; try &#123; // 使用数据的流程（略） &#125; finally &#123; readLock.unLock(); &#125;&#125; 上述示例中，当数据发生变更后，uodate变量（布尔类型且volatile修饰）被设置为false，此时所有访问processDate()方法的线程都能感知到变化，且只有一个线程能够获得到写锁，其他线程会被阻塞在读锁和写锁的lock()方法上。当前线程获取写锁完成数据准备之后，在获取读锁，随后释放写锁，完成锁降级。 锁降级中读锁的获取是否有必要呢？答案是必要的。主要是为了保证线程数据的可见性，如果当前线程不是获取读锁是指直接获取写锁，假设此刻另一个线程（记做线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，线程T将会被阻塞，知道当前线程释放读锁之后，线程T才能进行数据的更新。 4. 实现源码分析1. ReentrantReadWriteLock的继承关系12public class ReentrantReadWriteLock implements ReadWriteLock, java.io.Serializable ReentrantReadWriteLock继承了上面所说的ReadWriteLock。 2. ReentrantReadWriteLock中的变量123456/** Inner class providing readlock */private final ReentrantReadWriteLock.ReadLock readerLock;/** Inner class providing writelock */private final ReentrantReadWriteLock.WriteLock writerLock;/** Performs all synchronization mechanics */final Sync sync; ReadLock，WriteLock，Sync都是ReentrantReadWriteLock中的内部类。ReadLock是读锁，WriteLock是写锁，Sync是ReentrantReadWriteLock实现的关键。 3. ReentrantReadWriteLock的构造函数12345678public ReentrantReadWriteLock() &#123; this(false);&#125;public ReentrantReadWriteLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync(); readerLock = new ReadLock(this); writerLock = new WriteLock(this);&#125; 可以看到ReentrantReadWriteLock中也有公平锁和非公平锁，ReentrantReadWriteLock中默认的是非公平锁。 4. ReentrantReadWriteLock的内部类从上面我们知道AQS的状态state是一个int的值，在读写锁中，它的高16为用来计数读锁，低16位用来计数写锁，它们各自共有65535个状态， 2^16-1。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436abstract static class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 6317671515068378041L; /* * Read vs write count extraction constants and functions. * Lock state is logically divided into two unsigned shorts: * The lower one representing the exclusive (writer) lock hold count, * and the upper the shared (reader) hold count. */ // 分隔的位数 static final int SHARED_SHIFT = 16; // 用于读锁的高位部分，将1左移16位 static final int SHARED_UNIT = (1 &lt;&lt; SHARED_SHIFT); // 最大容量 static final int MAX_COUNT = (1 &lt;&lt; SHARED_SHIFT) - 1; // 写锁的掩码，用于状态的低16值有效 高16位全0，第16位全1 static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1; /** Returns the number of shared holds represented in count */ // 计算 readLock 的获取次数 static int sharedCount(int c) &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125; /** Returns the number of exclusive holds represented in count */ // 计算 writeLock 的获取次数，把c与EXCLUSIVE_MASK(高16位全0，第16位全1)做与 static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125; /** * A counter for per-thread read hold counts. * Maintained as a ThreadLocal; cached in cachedHoldCounter */ /** * 几乎每个获取readLock的线程都会包含一个HoldCounter用来记录 线程id与获取readLock的次数 * writeLock 的获取是由state的低位 及 AQS中的exclusiveOwnerThread 来进行记录 */ static final class HoldCounter &#123; int count = 0; // Use id, not reference, to avoid garbage retention final long tid = getThreadId(Thread.currentThread()); &#125; /** * ThreadLocal subclass. Easiest to explicitly define for sake * of deserialization mechanics. * ThreadLockHoldCounter继承了ThreadLocl，这里的继承主要是为了重写initialValue()这个方法 * 重写ThreadLocl的initialValue()方法的作用是：使得这个类的对象可以直接get()不用先set再get */ static final class ThreadLocalHoldCounter extends ThreadLocal&lt;HoldCounter&gt; &#123; public HoldCounter initialValue() &#123; return new HoldCounter(); &#125; &#125; /** * The number of reentrant read locks held by current thread. * Initialized only in constructor and readObject. * Removed whenever a thread's read hold count drops to 0. * 当前线程持有可重入读锁的数量 */ private transient ThreadLocalHoldCounter readHolds; /** * The hold count of the last thread to successfully acquire * readLock. This saves ThreadLocal lookup in the common case * where the next thread to release is the last one to * acquire. This is non-volatile since it is just used * as a heuristic, and would be great for threads to cache. * * &lt;p&gt;Can outlive the Thread for which it is caching the read * hold count, but avoids garbage retention by not retaining a * reference to the Thread. * * &lt;p&gt;Accessed via a benign data race; relies on the memory * model's final field and out-of-thin-air guarantees. * 最近一个成功获取可重入读锁的数量，这省却了ThreadLocl的查找 * 通常情况下，下一个释放的线程是最后一个获取线程，这不是volatile的 */ private transient HoldCounter cachedHoldCounter; /** * firstReader is the first thread to have acquired the read lock. * firstReaderHoldCount is firstReader's hold count. * * &lt;p&gt;More precisely, firstReader is the unique thread that last * changed the shared count from 0 to 1, and has not released the * read lock since then; null if there is no such thread. * * &lt;p&gt;Cannot cause garbage retention unless the thread terminated * without relinquishing its read locks, since tryReleaseShared * sets it to null. * * &lt;p&gt;Accessed via a benign data race; relies on the memory * model's out-of-thin-air guarantees for references. * * &lt;p&gt;This allows tracking of read holds for uncontended read * locks to be very cheap. * 第一个获取读锁的线程 * firstReaderHoldCount持有的是firstReader */ private transient Thread firstReader = null; private transient int firstReaderHoldCount; Sync() &#123; readHolds = new ThreadLocalHoldCounter(); setState(getState()); // ensures visibility of readHolds &#125; /* * Acquires and releases use the same code for fair and * nonfair locks, but differ in whether/how they allow barging * when queues are non-empty. */ /** * Returns true if the current thread, when trying to acquire * the read lock, and otherwise eligible to do so, should block * because of policy for overtaking other waiting threads. * 读锁是否需要阻塞 */ abstract boolean readerShouldBlock(); /** * Returns true if the current thread, when trying to acquire * the write lock, and otherwise eligible to do so, should block * because of policy for overtaking other waiting threads. * 写锁是否需要被阻塞 */ abstract boolean writerShouldBlock(); /* * Note that tryRelease and tryAcquire can be called by * Conditions. So it is possible that their arguments contain * both read and write holds that are all released during a * condition wait and re-established in tryAcquire. */ protected final boolean tryRelease(int releases) &#123; // 当前线程是否获取独占锁的线程 if (!isHeldExclusively()) throw new IllegalMonitorStateException(); // 进行state的释放操作 int nextc = getState() - releases; // 判断exclusive lock（写锁）是否释放完 boolean free = exclusiveCount(nextc) == 0; // 释放完毕 if (free) setExclusiveOwnerThread(null); setState(nextc); return free; &#125; protected final boolean tryAcquire(int acquires) &#123; /* * Walkthrough: * 1. If read count nonzero or write count nonzero * and owner is a different thread, fail. * 2. If count would saturate, fail. (This can only * happen if count is already nonzero.) * 3. Otherwise, this thread is eligible for lock if * it is either a reentrant acquire or * queue policy allows it. If so, update state * and set owner. */ Thread current = Thread.currentThread(); int c = getState(); // 写锁的数量 int w = exclusiveCount(c); // 如果c不为0，则写锁不能获取 if (c != 0) &#123; // (Note: if c != 0 and w == 0 then shared count != 0) // 如果写锁的数量为0，当前线程不是独占线程，那么说明是读锁占着当前线程 if (w == 0 || current != getExclusiveOwnerThread()) return false; // 否则的话判断是否能加锁 if (w + exclusiveCount(acquires) &gt; MAX_COUNT) throw new Error("Maximum lock count exceeded"); // Reentrant acquire setState(c + acquires); return true; &#125; // 如果写锁应该被阻塞或者设置CAS失败 if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) return false; // 把当前线程设置为独占线程 setExclusiveOwnerThread(current); return true; &#125; protected final boolean tryReleaseShared(int unused) &#123; Thread current = Thread.currentThread(); // 判断现在进行释放的release的线程是不是 firstReader if (firstReader == current) &#123; // assert firstReaderHoldCount &gt; 0; // 如果firstReaderHoldCount中的值为1，也就是获取了一次读锁，那么直接释放 if (firstReaderHoldCount == 1) firstReader = null; else firstReaderHoldCount--; &#125; else &#123; // 如果当前线程不是firstReader，那么获取缓存中的HoldCounter HoldCounter rh = cachedHoldCounter; // 如果缓存不为空，或者当前线程的id是不是缓存的id if (rh == null || rh.tid != getThreadId(current)) // 那么从当前线程的线程局部变量中的readHolds rh = readHolds.get(); int count = rh.count; // 如果当前线程中的读锁的数量&lt;=1，那么把当前线程中的HoldCounter释放 if (count &lt;= 1) &#123; readHolds.remove(); if (count &lt;= 0) throw unmatchedUnlockException(); &#125; --rh.count; &#125; for (;;) &#123; int c = getState(); // 读锁的数量减1，那么也就是减SHARED_UNIT（SHARED_UNIT第17位为1，其余为0） int nextc = c - SHARED_UNIT; // cas if (compareAndSetState(c, nextc)) // Releasing the read lock has no effect on readers, // but it may allow waiting writers to proceed if // both read and write locks are now free. // 返回值是判断 是否还有 readLock 没有释放完, 当释放完了会进行 后继节点的 唤醒( readLock 在进行获取成功时也进行传播式的唤醒后继的 获取 readLock 的节点) return nextc == 0; &#125; &#125; private IllegalMonitorStateException unmatchedUnlockException() &#123; return new IllegalMonitorStateException( "attempt to unlock read lock, not locked by current thread"); &#125; protected final int tryAcquireShared(int unused) &#123; /* * Walkthrough: * 1. If write lock held by another thread, fail. * 2. Otherwise, this thread is eligible for * lock wrt state, so ask if it should block * because of queue policy. If not, try * to grant by CASing state and updating count. * Note that step does not check for reentrant * acquires, which is postponed to full version * to avoid having to check hold count in * the more typical non-reentrant case. * 3. If step 2 fails either because thread * apparently not eligible or CAS fails or count * saturated, chain to version with full retry loop. */ Thread current = Thread.currentThread(); int c = getState(); // 如果当前线程获取写锁并且获取写锁的线程不是当前线程，那么返回-1 if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) return -1; // 获取读锁的数量 int r = sharedCount(c); // 如果读锁不用被阻塞，并且读锁的数量小于MAX_COUNT if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; // 读锁的状态加1 compareAndSetState(c, c + SHARED_UNIT)) &#123; // 如果是第一个获取读锁的，那么设置firstReader和firstReaderHoldCount if (r == 0) &#123; firstReader = current; firstReaderHoldCount = 1; // 如果firstReader出当前线程，那么肯定是读锁重入 &#125; else if (firstReader == current) &#123; // 第一个读锁重入的次数++ firstReaderHoldCount++; &#125; else &#123; // 获取缓存 HoldCounter rh = cachedHoldCounter; // 如果HoldCounter中存储的不是当前的线程 if (rh == null || rh.tid != getThreadId(current)) // 更新缓存 cachedHoldCounter = rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); rh.count++; &#125; return 1; &#125; return fullTryAcquireShared(current); &#125; /** * Full version of acquire for reads, that handles CAS misses * and reentrant reads not dealt with in tryAcquireShared. */ final int fullTryAcquireShared(Thread current)&#123; /** * This code is part redundant with that in * tryAcquireShared but is simpler overall by not * complicating tryAcquireShared with interactions between * retries and lazily reading hold counts */ HoldCounter rh = null; for(;;)&#123; int c= getState(); if(exclusiveCount(c) != 0)&#123; if(getExclusiveOwnerThread() != current) // 1. 若此刻 有其他的线程获取了 writeLock 则直接进行 return 到 aqs 的 sync queue 里面 return -1; // else we hold the exclusive lock; blocking here // would cause deadlock &#125;else if(readerShouldBlock())&#123; // 2. 判断 获取 readLock 的策略 // Make sure we're not acquiring read lock reentrantly if(firstReader == current)&#123; // 3. 若是 readLock 的 重入获取, 则直接进行下面的 CAS 操作 // assert firstReaderHoldCount &gt; 0 &#125;else&#123; if(rh == null)&#123; rh = cachedHoldCounter; if(rh == null || rh.tid != getThreadId(current))&#123; rh = readHolds.get(); if(rh.count == 0)&#123; readHolds.remove(); // 4. 若 rh.count == 0 进行 ThreadLocal.remove &#125; &#125; &#125; if(rh.count == 0)&#123; // 5. count != 0 则说明这次是 readLock 获取锁的 重入(reentrant), 所以即使出现死锁, 以前获取过 readLock 的线程还是能继续 获取 readLock return -1; // 6. 进行到这一步只有 当 aqs sync queue 里面有 获取 readLock 的node 或 head.next 是获取 writeLock 的节点 &#125; &#125; &#125; if(sharedCount(c) == MAX_COUNT)&#123; // 7. 是否获取 锁溢出 throw new Error("Maximum lock count exceeded"); &#125; if(compareAndSetState(c, c + SHARED_UNIT))&#123; // 8. CAS 可能会失败, 但没事, 我们这边外围有个 for loop 来进行保证 操作一定进行 if(sharedCount(c) == 0)&#123; // 9. r == 0 没有线程获取 readLock 直接对 firstReader firstReaderHoldCount 进行初始化 firstReader = current; firstReaderHoldCount = 1; &#125;else if(firstReader == current)&#123; // 10. 第一个获取 readLock 的是 current 线程, 直接计数器加 1 firstReaderHoldCount++; &#125;else&#123; if(rh == null)&#123; rh = cachedHoldCounter; &#125; if(rh == null || rh.tid != getThreadId(current))&#123; rh = readHolds.get(); // 11. 还是上面的逻辑, 先从 cachedHoldCounter, 数据不对的话, 再从readHolds拿数据 &#125;else if(rh.count == 0)&#123; readHolds.set(rh); // 12. 为什么要 count == 0 时进行 ThreadLocal.set? 因为上面 tryReleaseShared方法 中当 count == 0 时, 进行了ThreadLocal.remove &#125; rh.count++; cachedHoldCounter = rh; // cache for release // 13. 获取成功 &#125; return 1; &#125; &#125; &#125; /** * Performs tryLock for write, enabling barging in both modes. * This is identical in effect to tryAcquire except for lack * of calls to writerShouldBlock. */ final boolean tryWriteLock() &#123; Thread current = Thread.currentThread(); int c = getState(); if (c != 0) &#123; int w = exclusiveCount(c); if (w == 0 || current != getExclusiveOwnerThread()) return false; if (w == MAX_COUNT) throw new Error("Maximum lock count exceeded"); &#125; if (!compareAndSetState(c, c + 1)) return false; setExclusiveOwnerThread(current); return true; &#125; /** * Performs tryLock for read, enabling barging in both modes. * This is identical in effect to tryAcquireShared except for * lack of calls to readerShouldBlock. */ final boolean tryReadLock() &#123; Thread current = Thread.currentThread(); for (;;) &#123; int c = getState(); if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) return false; int r = sharedCount(c); if (r == MAX_COUNT) throw new Error("Maximum lock count exceeded"); if (compareAndSetState(c, c + SHARED_UNIT)) &#123; if (r == 0) &#123; firstReader = current; firstReaderHoldCount = 1; &#125; else if (firstReader == current) &#123; firstReaderHoldCount++; &#125; else &#123; HoldCounter rh = cachedHoldCounter; if (rh == null || rh.tid != getThreadId(current)) cachedHoldCounter = rh = readHolds.get(); else if (rh.count == 0) readHolds.set(rh); rh.count++; &#125; return true; &#125; &#125; &#125; protected final boolean isHeldExclusively() &#123; // While we must in general read state before owner, // we don't need to do so to check if current thread is owner return getExclusiveOwnerThread() == Thread.currentThread(); &#125; // Methods relayed to outer class final ConditionObject newCondition() &#123; return new ConditionObject(); &#125; final Thread getOwner() &#123; // Must read state before owner to ensure memory consistency return ((exclusiveCount(getState()) == 0) ? null : getExclusiveOwnerThread()); &#125; final int getReadLockCount() &#123; return sharedCount(getState()); &#125; final boolean isWriteLocked() &#123; return exclusiveCount(getState()) != 0; &#125; final int getWriteHoldCount() &#123; return isHeldExclusively() ? exclusiveCount(getState()) : 0; &#125; final int getReadHoldCount() &#123; if (getReadLockCount() == 0) return 0; Thread current = Thread.currentThread(); if (firstReader == current) return firstReaderHoldCount; HoldCounter rh = cachedHoldCounter; if (rh != null &amp;&amp; rh.tid == getThreadId(current)) return rh.count; int count = readHolds.get().count; if (count == 0) readHolds.remove(); return count; &#125; /** * Reconstitutes the instance from a stream (that is, deserializes it). */ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; s.defaultReadObject(); readHolds = new ThreadLocalHoldCounter(); setState(0); // reset to unlocked state &#125; final int getCount() &#123; return getState(); &#125;&#125;]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>Java</tag>
        <tag>锁</tag>
        <tag>读写锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot中的数据校验]]></title>
    <url>%2F2019%2F04%2F08%2FSpringBoot%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[Spring Boot中的数据校验我们可能会经常需要对传入的参数进行校验，如果数据比较少的时候还比较容易处理，但当数据比较多的时候会显得比较麻烦，而且处理不当的时候，还会代码重复。这时候就需要Spring Boot对参数进行校验了。这时候就需要使用使用Validation对数据进行校验了。 在Spring Boot中使用Validation有如下的一段代码：12345678@RestControllerpublic class BookController &#123; @PostMapping("/book") public Book getBook(Book book) &#123; // ... return book; &#125;&#125; 可以看到请求传入了一个Book，Book类如下：123456public class Book &#123; private Integer id; private String bookName; private String bookAuthor; // 省略get和set方法&#125; 现在需要对book中的属性进行校验，如果使用if else 进行校验会显得很麻烦。这时候可以在Book中的属性上添加Validation注解，如下：12345678public class Book &#123; private Integer id; @NotBlank private String bookName; @NotBlank private String bookAuthor; // 省略get和set方法&#125; 其中的NotBlank注解指的是属性值不能为空。然后还需要在Controller中的方法的需要校验的字段上加上@Valid注解，表明这个参数需要校验，如下：12345678@RestControllerpublic class BookController &#123; @PostMapping("/book") public Book getBook(@Valid Book book) &#123; // ... return book; &#125;&#125; 这时候假如bookName和bookAuthor为空，那么就会出现400的响应码。Spring Boot这时的返回为：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&#123; "timestamp": "2018-07-25T01:21:53.644+0000", "status": 400, "error": "Bad Request", "errors": [ &#123; "codes": [ "NotBlank.book.bookAuthor", "NotBlank.bookAuthor", "NotBlank.java.lang.String", "NotBlank" ], "arguments": [ &#123; "codes": [ "book.bookAuthor", "bookAuthor" ], "arguments": null, "defaultMessage": "bookAuthor", "code": "bookAuthor" &#125; ], "defaultMessage": "不能为空", "objectName": "book", "field": "bookAuthor", "rejectedValue": "", "bindingFailure": false, "code": "NotBlank" &#125;, &#123; "codes": [ "NotBlank.book.bookName", "NotBlank.bookName", "NotBlank.java.lang.String", "NotBlank" ], "arguments": [ &#123; "codes": [ "book.bookName", "bookName" ], "arguments": null, "defaultMessage": "bookName", "code": "bookName" &#125; ], "defaultMessage": "不能为空", "objectName": "book", "field": "bookName", "rejectedValue": "", "bindingFailure": false, "code": "NotBlank" &#125; ], "message": "Validation failed for object='book'. Error count: 2", "path": "/book"&#125; 因为使用的是测试工具，所以Spring Boot返回的是Json串。上面的是Spring Boot的默认返回，我们肯定不希望返回这样的一个东西给前端。所以就需要自定义错误信息和错误处理。 自定义校验信息和错误处理Validation注解中都有一个message的属性可以通过这个属性自定义错误信息。如下：12345678public class Book &#123; private Integer id; @NotBlank(message = "书名不能为空") private String bookName; @NotBlank(message = "作者不能为空") private String bookAuthor; // 省略get和set方法&#125; Spring Boot的Controller方法中可以传一个BindingResult或者Errors类型的参数，值得注意的一点是这个参数的位置必须是参数列表的被@Valid注解修饰的参数紧跟着的（也就是被@Valid修饰的下一个参数）后面，如果在前面，会出现下面的错误，如果不是下一个，那么这个参数将不起作用。1234567&#123; "timestamp": "2018-07-25T01:49:10.742+0000", "status": 500, "error": "Internal Server Error", "message": "An Errors/BindingResult argument is expected to be declared immediately after the model attribute, the @RequestBody or the @RequestPart arguments to which they apply: public top.mcwebsite.demo.domain.Book top.mcwebsite.demo.web.controller.BookController.getBook(org.springframework.validation.BindingResult,top.mcwebsite.demo.domain.Book,javax.servlet.http.HttpServletResponse)", "path": "/book"&#125; 下面的代码是如何进行自定义错误处理：12345678910111213141516171819@RestControllerpublic class BookController &#123; @PostMapping("/book") public Book getBook(@Valid Book book, BindingResult result, HttpServletResponse response) &#123; if (result.hasErrors()) &#123; result.getAllErrors().forEach((error) -&gt; &#123; FieldError fieldError = (FieldError) error; // 属性 String field = fieldError.getField(); // 错误信息 String message = fieldError.getDefaultMessage(); System.out.println(field + ":" + message); &#125;); &#125; // ... return book; &#125;&#125; 结果：这里的错处处理只是简单的打印。 这里的错误消息也可以做成国际化的，具体做法可以自己取研究。 当需要校验的Bean比较多的时候这样也会显得比较麻烦，所以这时候就可以使用Spring Boot的异常处理机制了。 Spring Boot的异常处理＋Bean ValidationSpring Boot 中有一个专门处理错误信息的一个类叫做ResponseEntityExceptionHandler。其中有很多关于400的错误处理，也就是参数错误的处理，其中就有一个专门用来处理没有通过校验的参数的方法。我们重写这个类的这个方法即可。12345678910111213141516171819202122@ControllerAdvice // Spring 的异常处理的注解public class BadRequestExceptionHandler extends ResponseEntityExceptionHandler &#123; private Logger logger = LoggerFactory.getLogger(getClass()); @Override protected ResponseEntity&lt;Object&gt; handleBindException(BindException ex, HttpHeaders headers, HttpStatus status, WebRequest request) &#123; Map&lt;String, String&gt; messages = new HashMap&lt;&gt;(); BindingResult result = ex.getBindingResult(); if (result.hasErrors()) &#123; List&lt;ObjectError&gt; errors = result.getAllErrors(); for (ObjectError error : errors) &#123; FieldError fieldError = (FieldError) error; messages.put(fieldError.getField(), fieldError.getDefaultMessage()); &#125; logger.error(messages.toString()); &#125; return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(messages); &#125;&#125; 这时候controller中的方法中就不需要BindingResult或者Errors类型的参数了。 一些常用的Validation注解 注解 作用 @NotNull 值不能为空 @Null 值必须为空 @Pattern(regex=) 字符串必须匹配正则表达式 @Size(min, max) 集合元素的数量必须在min和max之间 @CreditCardNumber(ignoreNonDigitCharacters=) 字符串必须是信用卡号，按找美国的标准验证 @Email 字符串必须是Email地址 @Length(min, max) 检查字符串的长度 @NotBlank 字符串不能为空串 @NotEmpty 字符串不能为null, 集合必须有元素 @Range(min, max) 数字必须大于min, 小于max @SafeHtml 字符串必须是安全的html @URL 字符串必须是合法的URL @AssertFalse 值必须是false @AssertTrue 值必须是true @DecimalMax(value=, inclusive=) 值必须小于等于(inclusive=true)/小于(inclusive=false)属性指定的值，也可以注释在字符串类型的属性上。 @DecimalMin(value=, inclusive=) 值必须大于等于(inclusive=true)/小于(inclusive=false)属性指定的值，也可以注释在字符串类型的属性上。 @Digist(integer=,fraction=) 数字格式检查。integer指定整数部分的最大长度，fraction指定小数部分的最大长度 @Future 时间必须是未来的 @Past 事件必须是过去的 @Max(value=) 值必须小于等于value指定的值。不能注解在字符串类型属性上。 @Min(value=) 值必须小于等于value指定的值。不能注解在字符串类型属性上。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>校验</tag>
        <tag>Validation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发之无锁]]></title>
    <url>%2F2019%2F04%2F07%2FJava%E5%B9%B6%E5%8F%91%E4%B9%8B%E6%97%A0%E9%94%81%2F</url>
    <content type="text"><![CDATA[Java并发编程之无锁在谈论无所之前先来看看乐观派和悲观派。对于乐观派而言，他们总认为事情总会朝着好的方向发展，总认为几乎不会坏事，我已可以随意的去做事。但是对于悲观派来说，他们认为出错是一种常态，所以无论事情大小都会考虑的面面俱到，滴水不漏。 在两种派别对应在并发中就是加锁和无锁，也就是说加锁是一种悲观的策略，而无锁是一种乐观的策略。对于锁，如果有多个线程同事访问一个临界资源，宁可牺牲性能让线程等待，也不会让一个线程不加锁访问临界资源。对于无锁，它会假定对资源的访问是没有冲突的。也就是多个线程对临界资源的访问是没有冲突的。既然没有冲突，那么就不需要等待，所有的线程都可以不需要等待的执行下去。如果遇到了冲突，怎么办？这里无锁策略使用了一种称为CAS的技术来保证线程执行的安全性。下面我们来具体讨论一下CAS。 无锁解决冲突的办法：CASCAS的全称是Compare And Swap即比较和交换。 CAS算法的过程是这样的：它包含三个参数的变量CAS(V, E, N)。作用如下： V 表示要更新的值。 E 表示预期的值。 N 表示新值。 仅当V值等于E值的，才会将V值设置为N值，如果V值和E值不同，则说明已经有其他线程做了更新，当前线程什么都不做。CVS返回的是当前V的真实值。CAS是乐观派，总认为自己可以操作成功。当多个线程同时使用CAS来给一个变量设置时，只有一个会成功，其它的都会失败，但是CAS很乐观，失败了就失败了，可以再次尝试。 Java中的指针：Unsafe类What? Java中也有指针。Unsfae类就像它的名字一样，不安全，里面有一些向C语言的指针一样直接操作内存的方法。并且官方也不推荐直接使用Unsafe类。但是CAS的实现用到了这个类。下面来看看Unsafe中的一些方法： 1234567891011121314151617181920// 分配内存public native long allocateMemory(long var1);// 重新分配内存public native long reallocateMemory(long var1, long var3);// 拷贝内存public native void copyMemory(Object var1, long var2, Object var4, long var5, long var7);// 释放内存public native void freeMemory(long var1);// 获取起始地址public native long getAddress(long var1);// 获取操作系统内存页大小public native int pageSize();..... Unsafe中有两个方法可以将线程挂起和恢复，如下： 12345// 线程调用方法，将线程挂起public native void unpark(Object var1);// 线程恢复public native void park(boolean var1, long var2); Unsafe中的关于CAS的操作： 12345public final native boolean compareAndSwapObject(Object var1, long var2, Object var4, Object var5);public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6); CAS的操作的核心实现是这三个方法。三个方法的参数都类似，分别为： CAS需要更改变量的对象； 对象内存的偏移量; 期望值 需要设置的值 其中偏移量可以通过Unsafe类中的objectFieldOffset()方法获取到，这些方法如下： 1public native long objectFieldOffset(Field field); 因为int，long，boolean类型的相关操作不是原子性的，所以JDK在1.5之后提供了atomic包（具体在java.util.concurrent.atomic中）来将这些操作变成原子操作。 下面的图片中的是atomic下提供的原子操作的类： 这里以AtomicInteger来进行分析： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public class AtomicInteger extends Number implements java.io.Serializable &#123; // 实例化Unsafe private static final Unsafe unsafe = Unsafe.getUnsafe(); // valueOffset变量保存的是value中的偏移量，这一点可以在下面的static初始化块中可以看出 private static final long valueOffset; static &#123; try &#123; // 获取value的偏移量 valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(&quot;value&quot;)); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile int value; /** * 通过int值实例化一个AtomicInteger对象 */ public AtomicInteger(int initialValue) &#123; value = initialValue; &#125; /** * 实例化一个AtomicInteger对象，其初始值为0 */ public AtomicInteger() &#123; &#125; // 获取当前值 public final int get() &#123; return value; &#125; // 设置当前值 public final void set(int newValue) &#123; value = newValue; &#125; // 延迟设值 public final void lazySet(int newValue) &#123; unsafe.putOrderedInt(this, valueOffset, newValue); &#125; // 设置新值获取旧值 public final int getAndSet(int newValue) &#123; return unsafe.getAndSetInt(this, valueOffset, newValue); &#125; // CAS操作，把当前值和预期值做比较，相当时设置新值 public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update); &#125; public final boolean weakCompareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update); &#125; // 当前值加1，返回旧值 public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1); &#125; // 当前值-1，返回旧值 public final int getAndDecrement() &#123; return unsafe.getAndAddInt(this, valueOffset, -1); &#125; // 当前值加上delta，然后返回旧值 public final int getAndAdd(int delta) &#123; return unsafe.getAndAddInt(this, valueOffset, delta); &#125; // 当前值加1，然后返回 public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1; &#125; // 当前值减1，返回返回 public final int decrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, -1) - 1; &#125; // 当前值加上delta，然后返回 public final int addAndGet(int delta) &#123; return unsafe.getAndAddInt(this, valueOffset, delta) + delta; &#125; // ...&#125; 其中的大部分方法都直接或者间接使用了CAS来保证安全。 除了上面的对于基本变量的Atomic类，还有关于普通对象引用的Atmoic类。 AtomicReference 无锁的引用AtomicReference和AtmoicInteger非常类似，不同之处就是AtmoicInteger是对整数的封装，而AtmoicReference是对普通对象的引用，也就是它可以保证在修改对象引用时线程的安全性。 CAS中有一个很重要的问题ABA。CAS比较的是对象中的值和期望值，但是有可能在你获取到当前对象的数据后，在准备修改为新值之前，对象的值被其他线程连续修改两次，而且经过这两次修改之后，对象有恢复为旧值。这样，前后的结果看似没有被改过，但是其实已经被修改了2次。过程如下图： 一般来说，发生这种事情的可能性很小。而且即使发生了也不会有什么影响，比如，一个数字，被修改一次后，在修改回去，不会对CAS产生什么影响。 但是有时候在一些具体问题中这种情况就有可能发生。所以在JDK中提供了AtomicStampedReference来解决这种问题。 AtomicStampedReferenceAtomicStampedReference在内部维护了一个时间戳。当AtmoicStampedReference对应的数字被修改时，除了更新数据本身，还必须更新时间戳。当AtomicStampedReference设置对象值时，对象和时间戳都必须满足期望值，才会写入成功。通过维护时间戳能有效的防止ABA问题。 AtmoicStampedReference的几个API在Atmomic的基础上新增了几个有关时间戳的信息。 1234567891011// 参数为：期望值，新值，期望时间戳，新的时间戳public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp);// 获取索引public V getReference()// 获取时间戳public int getStamp()// 设置当前对象引用和时间戳public void set(V newReference, int newStamp)]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>Java</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库的事务和并发问题.md]]></title>
    <url>%2F2019%2F04%2F06%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%92%8C%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98-md%2F</url>
    <content type="text"><![CDATA[数据库事务事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么全部执行，要么全部都不执行。比如，银行转账，从一个账号扣钱，然后另一个账号余额增加，这两个操作要么都执行，要么都不执行。这两个操作组合在一起就是事务。 数据库事务有严格的定义，它必须同时满足4个特性： 原子性，Atomic 一致性，Consistency 隔离性， Isolation 持久性，Durabiliy 简称ACDI。下面是对每一个特性的说明： 原子性：表示组成一个事务的多个数据库操作是一个密不可分的原子单元，只有所有的操作执行成功，整个事务才提交。事务中的任何一个数据库操作失败，已经执行的任何操作都必须撤销（回滚），让数据库恢复到事务提交之前的状态。 一致性：数据库总是从一个一致性状态装换到另一个一致性状态。一致性状态的含义是数据库中的数据应该满足数据库约束。 隔离性：在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对对方产生干扰。但是也并非要做到完全无干扰。数据库规定了多个隔离级别，不同的隔离级别的干扰程度是不同，隔离级别越高，数据一致性越好，但并发性越弱。 持久性：一旦数据库提交之后，事务中的所有操作都必须被持久化都数据库中。即使在提交事务后，数据库重启时，也必须保证能够通过某种机制恢复数据。 在这些事务的特征中，数据”一致性“是最终目标，其他特性都是为达到这个目标而采取的措施。 数据库并发的问题一个数据库可能会有多个客户端同时访问，数据库中相同的数据就有可能同时被多个事务访问，如果没有采取必要的隔离措施，就会导致各种问题，破坏数据的完整性，这些问题可以分为5中，两类： 数据读取的问题： 脏读 不可重复读 幻想读 数据更新问题 第一类丢失更新 第二类丢失更新 1. 脏读（direct read）A事务读取B事务尚未提交更改的数据，并在这个数据的基础上进行操作。如果恰巧B事务回滚，那么A事务读取到的数据是不被承认的。通过一个取款事务和转账事务来说明这个问题。 时间 转账事务A 取款事务B T1 开始事务 T2 开始事务 查询账户余额1000元 T3 取出500元，把余额改为500元 T4 查询余额500元（脏读） T5 撤销事务，余额恢复为1000元 T6 汇入100元，把余额改为600元 T8 提交事务 &nbsp; 在这个场景中转账事务A读取到取款事务B中的未提交的数据，导致脏读。 2. 不可重复读(unrepeatable read)不可重复读是指A事务读取B事务已经提交更改的数据。假设A在取款事务的过程中，B往该账户转账100元，A两次读取账户的余额不一致。 时间 取款事务A 转账事务B T1 开始事务 T2 开始事务 T3 查询账户余额为1000元 T4 查询账户余额1000元 T5 取出100元，把余额改为900元 T6 查询事务 T7 查询账户余额为900元 &nbsp; 在同一事务中，T4和T7时间点读取的账户余额不一致。 3. 幻想读(phantom read)A事务读取B事务提交的新增数据，这时A事务将出现幻想读现象。幻想读一般发生在计算统计数据的事务中。 举个例子，比如在银行系统的同一个事务中有两次统计存款用户的总金额，在两次统计中刚好新增了一个存款，这时，两次统计的结构将会不一致。 时间 统计金额事务A 转账事务B T1 开始事务 T2 开始事务 T3 统计总存款为1000元 T4 新增一个存款账户，存款100元 55 提交事务 T6 再次统计总存款数为10100元（幻想读） &nbsp; 如果新增的数据刚好满足事务的查询条件，那么这个新数据就会出现事务的视野中，因而产生了两次结构不一致。 幻想读和不可重复读这两个概念比较容易混淆，幻想读是指读到了其他已经提交的事务的新增数据，而不可重复读是指读到了已经提交的更改数据（更改或者删除）。 为了避免这两种情况，采取的对策是不同的：防止读到更新的数据，只需要对操作的数据添加行级锁，阻止操作中的数据发生改变；而防止读到新增的数据，则往往需要添加表级锁——将整张表加锁，防止新增数据。 4. 第一类丢失更新第一类丢失更新是一个事务撤销时把另一个事务的数据覆盖了。下面通过一个转账的例子来看一下这个问题。 时间 取款事务A 转账事务B T1 开始事务 T2 开始事务 T3 查询余额为1000元 T4 查询余额为1000元 T5 汇入100元，把余额修改为1100元 T6 提交事务 T7 取出100元，把余额修改为900元 T8 撤销修改 &nbsp; T9 把余额恢复为1000元（丢失更新） &nbsp; 5. 第二类丢失更新一个事务覆盖另一个事务已经提交的数据。造成另一个事务所做的操作丢失。 时间 取款事务A 转账事务B T1 开始事务 T2 开始事务 T3 查询账户余额为1000元 T4 查询账户余额为1000元 T5 取出100元，把余额修改为900元 T6 提交事务 T7 汇入100元 &nbsp; T8 提交事务 &nbsp; T9 把余额修改为1100元（丢失更新） &nbsp;&nbsp; 总结：第一类为撤销时覆盖，第二类为提交时覆盖。 数据库锁机制数据库的并发会引起很多问题，当然有些问题还可以容忍，但是有的问题却是致命的。并发问题一般都会用锁解决，在数据库中也是用锁解决的，但是不同的数据库对于锁的实现是不同的，但基本的原理是相同。 按锁定的对象可以分为： 表锁定：对于整张表锁定 行锁定：对于表中的特定行锁定 从并发的数据关系中又可以分为 独占锁：共享锁会防止独占锁，但允许其他共享锁的访问。 共享锁：独占锁独自占领表或行，防止其他共享锁的访问，当然也访问其他独占锁。 在数据更新的时候，数据库必须在进行更改的行上施加行独占锁，也就是说INSERT,UPDATE,DELETE等语句都会隐式采用必要的行锁定。 事务的隔离级别尽管数据库为用户提供了锁的DML操作方式，但是直接使用还是很麻烦的，因此数据库为用户提供了自动锁的机制。也就是隔离级别，只要用户指定的回话的隔离级别，数据库就会分析SQL语句，然后进行合适的加锁，当数据锁的数据太多的时候，自动进行锁升级来提高系统的，性能，这一过程对用户是透明的（不可见）的。 SQL标准定义了4个事务级别，每一个级别都规定了一个事务中所做的修改，哪些在事务中是可见的，哪些是不可见的。较低的隔离通常可以执行更高的并发，系统开销也更低。 下面的是四中数据库事务的介绍： READ UNCOMMITED（未提交读）事务中的修改，即使没有提交对其它事务都是可见的。事务可以读取未提交的数据，这也被称为脏读。一般很少使用。 READ COMMITED（提交读）大多数的数据库的默认隔离级别都是READ COMMITED。READ_COMMITED从一个事务开始时，只能”看见“已经提交的修改。也就是说：一个事务从开始到提交前，所做的任何修改对其他事务是不可见的。这个级别有时候也叫做不可重复读，因为两次执行查询可能会得到不同的结果。 REPEATABLE READ（可重复读）REPEATABLE READ解决了脏读的问题，该级别保证在同一个事务中多次读取同样的记录的结果是一致的。但是这个级别还是没有解决另一个问题：幻读。 SERIALIZABLE（可串行化）SERIALIZABLE是最高的隔离级别。它通过事务串执行，避免了前面所说的幻读问题。简单来说SERIALIZABLE会为每一行数据都加锁，所以会导致大量的锁超时和竞争。实际中很少使用这个隔离级别。 下表为事务隔离级别对并发问题的解决情况： 隔离级别 脏读 不可重复读 幻想读 第一类丢失更新 第二类丢失更新 READ UNCOMMITED 允许 允许 允许 不允许 允许 READ COMMITED 不允许 允许 允许 不允许 允许 REPEATABLE READ 不允许 不允许 允许 不允许 不允许 SERIALIZABLE 不允许 不允许 不允许 不允许 不允许 其中READ UNCOMMITED并发性和吞吐量最好，SERIALIZABLE的最差，所以事务的隔离级别和数据库的并发行是对立的。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
