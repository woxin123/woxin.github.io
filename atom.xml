<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Enthusiasm</title>
  
  <subtitle>Enthusiasm</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-19T03:35:36.869Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>woxin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go语言之map</title>
    <link href="http://yoursite.com/2019/06/19/Go%E8%AF%AD%E8%A8%80%E4%B9%8Bmap/"/>
    <id>http://yoursite.com/2019/06/19/Go语言之map/</id>
    <published>2019-06-19T03:33:34.000Z</published>
    <updated>2019-06-19T03:35:36.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>散列表（经常被称为哈希表，但是更准确的说是散列表）是一个非常优秀的数据结构。它是一个拥有键值对的无序集合。在这个集合中，可以通过唯一的键找到一个与之对应的值，并且可以通过这个键进行删、改和查。并且这个查询可以在常量的时间内完成。</p><p>在高级语言中基本都有map数据结构（有的名字不同，功能相同），Go语言也不例外。在Go语言中，<code>map</code>是散列表的引用，<code>map</code>的类型是<code>map[K]V</code>，其中K和V是字典的键和值对应的数据类型。<code>map</code>中的所有键都拥有相同的类型，所有的值也拥有相同的数据类型。其中键的类型必须是可以通过操作符<code>==</code>来比较的数据类型，所以<code>map</code>可以检测某一个值是否已经存在。值类型是没有任何限制的。</p><p>可以通过内置函数<code>make</code>来创建一个<code>map</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)  <span class="comment">// 这里创建一个从string到int的map</span></span><br></pre></td></tr></table></figure><p>也可以通过使用<code>map</code>的字面量来创建一个带初始化键值对的<code>map</code>:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ages := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;</span><br><span class="line">    <span class="string">"alice"</span>: <span class="number">31</span>,</span><br><span class="line">    <span class="string">"charlie"</span>: <span class="number">34</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，也可以不写初始化，只写一个花括号来创建一个空的<code>map</code>，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map[string]int&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="map的基本操作-增、删、改、查"><a href="#map的基本操作-增、删、改、查" class="headerlink" title="map的基本操作(增、删、改、查)"></a>map的基本操作(增、删、改、查)</h3><p>map的元素访问和数组类似，都是通过下标的方式来访问：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加键值对或更新键值对（如果map中没有对应的key，则新增，有则更新）</span></span><br><span class="line">ages[<span class="string">"alice"</span>] = <span class="number">32</span></span><br><span class="line">fmt.Println(ages[<span class="string">"alice"</span>])  <span class="comment">// "32"</span></span><br></pre></td></tr></table></figure><p>删除可以通过内置的<code>delete</code>函数来从字典中根据键删除一个元素：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(ages, <span class="string">"alice"</span>) <span class="comment">// 删除元素 ages["alice"]</span></span><br></pre></td></tr></table></figure><p>及时<code>map</code>中不存在对应的键，上面的操作也是安全的。<strong><code>map</code>使用给定的键来查找元素，如果对应的元素不存在，那么返回的是值类型对应的零值。</strong> 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ages[&quot;bob&quot;] = ages[&quot;bob&quot;] + 1</span><br></pre></td></tr></table></figure><p>尽管<code>map</code>中没有“bob”对应的键，也不会报错，因为<code>ages[&quot;bob&quot;]</code>的值是0。</p><p>那么这里就有一个问题，如何判断<code>map</code>中的某一个键是否存在？</p><p>这里可以通过<code>map</code>下标访问返回多个值来判断。下标访问可以返回两个值，一个是对应的<code>value</code>，另一个是一个<code>bool</code>类型，用来表示该键是否存在对应的值。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">age, ok := ages[&quot;bob&quot;]</span><br><span class="line">if !ok &#123;</span><br><span class="line">    /*</span><br><span class="line">    &quot;bob&quot;不是map中的键，age == 0</span><br><span class="line">    */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般而言，第二个<code>bool</code>值被叫做ok。</p><p><code>map</code>也可以使用<code>+=、-=、++、--</code>等赋值方式。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ages[&quot;bob&quot;] += 1</span><br><span class="line">// 或者</span><br><span class="line">ages[&quot;bob&quot;]++</span><br></pre></td></tr></table></figure><p>但是无法获取<code>map</code>元素的地址，比如这样是不对的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ = &amp;ages[&quot;bob&quot;] // 编译错误，无法获取map元素的地址</span><br></pre></td></tr></table></figure><p><strong>无法获取<code>map</code>元素的地址是因为<code>map</code>的增长可能会导致已有的元素被重新散列到新的存储位置，这样就可以导致获取的地址是其他元素的地址吗，从而导致指针出现不安全。</strong></p><p>map的遍历可以通过<code>for</code>循环来完成，和遍历<code>slice</code>一样。循环语句的连续迭代会使得变量<code>name</code>和<code>age</code>被赋予<code>map</code>中的一下对键和值。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name, age := ranges ages &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s\t%d\n"</span>, name, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以省略值，而只保留键，如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name := ranges ages &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s\n"</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map</code>中元素迭代顺序是不固定的，它的顺序是通过散列算法散列得到的，不同的散列算法会到的不同的散列序列。可以认为这种顺序是随机的。</p><p>Go语言没有提供集合的功能，但是可以使用<code>map</code>来模拟集合的功能。</p><blockquote><p>如果对Java有点了解的话，就会知道Java中的集合<code>set</code>也是通过<code>map</code>来实现的。</p></blockquote><p>和slice一样，map也是不可比较的，唯一可以比较的就是<code>nil</code>。</p><p>下面的一个关于使用<code>map</code>模拟集合的一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;bufio&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">seen := make(map[string]bool)</span><br><span class="line">input := bufio.NewScanner(os.Stdin)</span><br><span class="line">for input.Scan() &#123;</span><br><span class="line">line := input.Text()</span><br><span class="line">if !seen[line] &#123;</span><br><span class="line">seen[line] = true</span><br><span class="line">fmt.Println(line)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if err := input.Err(); err != nil &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, &quot;dedup: %v\n&quot;, err)</span><br><span class="line">os.Exit(1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;map&quot;&gt;&lt;a href=&quot;#map&quot; class=&quot;headerlink&quot; title=&quot;map&quot;&gt;&lt;/a&gt;map&lt;/h1&gt;&lt;p&gt;散列表（经常被称为哈希表，但是更准确的说是散列表）是一个非常优秀的数据结构。它是一个拥有键值对的无序集合。在这个集合中，可以通过唯一
      
    
    </summary>
    
      <category term="Go语言" scheme="http://yoursite.com/categories/Go%E8%AF%AD%E8%A8%80/"/>
    
      <category term="复合数据类型" scheme="http://yoursite.com/categories/Go%E8%AF%AD%E8%A8%80/%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
      <category term="Go语言" scheme="http://yoursite.com/tags/Go%E8%AF%AD%E8%A8%80/"/>
    
      <category term="map" scheme="http://yoursite.com/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>CORS跨域详解</title>
    <link href="http://yoursite.com/2019/05/08/CORS%E8%B7%A8%E5%9F%9F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/05/08/CORS跨域详解/</id>
    <published>2019-05-08T02:56:39.000Z</published>
    <updated>2019-05-08T03:04:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>转载自阮一峰，链接：<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></p><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>CORS是一个W3C标准，全称是“跨域资源共享”（Corss-origin resource sharing）。</p><p>它允许浏览器向跨源服务器，发出<code>XMLHttpRequest</code>请求，从而克服了AJAX只能同源使用的限制。</p><p>CORS需要浏览器和服务器同时支持。目前，所有的浏览器都支持该功能，IE浏览器的内核不能低于IE10。</p><p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对开发者来说，CORS通信与源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX跨域，就会自动添加一些附加的头信息，有时还会多出一次附加请求，但用户感觉不到。</p><h2 id="二、两种请求"><a href="#二、两种请求" class="headerlink" title="二、两种请求"></a>二、两种请求</h2><p>浏览器将CORS请求分为两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p><p>只要满足一下两大条件，就属于非简单请求。</p><ol><li><p>请求方法是以下三个方法之一：</p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul></li><li><p>HTTP 的头信息不超出以下几个字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于application/x-www-form-urlencode、multipart/form-data、text/plain</li></ul></li></ol><p>凡是不同时满足上面两个条件，就属于非简单请求。</p><p>浏览器对于这两种请求的处理，是不一样的。</p><h2 id="三、简单请求"><a href="#三、简单请求" class="headerlink" title="三、简单请求"></a>三、简单请求</h2><h3 id="3-1-基本流程"><a href="#3-1-基本流程" class="headerlink" title="3.1 基本流程"></a>3.1 基本流程</h3><p>对于简单请求，浏览器直接发出CORS请求。具体来说。就是在头信息之中，增加一个<code>Origin</code>字段。</p><p>下面是一个例子，浏览器发现这次跨域AJAX请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/cors</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Origin</span>: http://api.bob.com</span><br><span class="line"><span class="attribute">Host</span>: api.alice.com</span><br><span class="line"><span class="attribute">Accept-Language</span>: en-US</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0...</span><br></pre></td></tr></table></figure><p>下面的头信息，<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器更具这个值，决定是否同意这次请求。</p><p>如果<code>Origin</code>指定的源，不在许可范围内，服务器就返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p><p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span>: http://api.bob.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span>: true</span><br><span class="line"><span class="attribute">Access-Control-Expose-Headers</span>: FooBar</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><p>上面的头信息之中，有三个与CORS请求相关的字段，都以<code>Access-Control-</code>开头。</p><h4 id="（1）Access-Control-Allow-Origin"><a href="#（1）Access-Control-Allow-Origin" class="headerlink" title="（1）Access-Control-Allow-Origin"></a>（1）Access-Control-Allow-Origin</h4><p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接收任意域名请求。</p><h4 id="（2）Access-Control-Allow-Credentials"><a href="#（2）Access-Control-Allow-Credentials" class="headerlink" title="（2）Access-Control-Allow-Credentials"></a>（2）Access-Control-Allow-Credentials</h4><p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求中。设为<code>true</code>表示服务器明确许可，Cookie可以包含在请求中，一起发送给服务器。这个值只能设为<code>true</code>，如果服务器不要浏览器发送Cookie，删除该字段即可。</p><h4 id="（3）Access-Control-Expose-Headers"><a href="#（3）Access-Control-Expose-Headers" class="headerlink" title="（3）Access-Control-Expose-Headers"></a>（3）Access-Control-Expose-Headers</h4><p>该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。</p><p>如果想要拿到其他字段，就必须在<code>Access-Control-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值。</p><h3 id="3-2-withCredentials属性"><a href="#3-2-withCredentials属性" class="headerlink" title="3.2 withCredentials属性"></a>3.2 withCredentials属性</h3><p>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发送到服务器，一方面要服务器通信，指定<code>Access-Control-Allow-Credentials</code>字段。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span>: true</span><br></pre></td></tr></table></figure><p>另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。</p><p>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会发送Cookie。这时，可以显示关闭<code>withCredentials</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.withCredentials = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果要发送Cookie，<code>Access-Control-Allow-Origin</code>就不能设置为<code>*</code>号，必须明确的、与请求网页一致的域名。同时，Cookie依然遵循同源策略。只有服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie。</p><h2 id="四、非简单请求"><a href="#四、非简单请求" class="headerlink" title="四、非简单请求"></a>四、非简单请求</h2><h3 id="4-1-预测请求"><a href="#4-1-预测请求" class="headerlink" title="4.1 预测请求"></a>4.1 预测请求</h3><p>非简单请求是那种对服务器有特殊要求的请求，比如请求的方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p><p>非简单请求的CORS，会在正式通信之前，增加一次HTTP查询请求，称为“预测”请求（preflight）。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到了肯定答复，浏览器才会正式的<code>XMLHttpRequest</code>请求，否则就报错。</p><p>下面是一段浏览器的JavaScript脚本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'http://api.alice.com/cors'</span>;</span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'PUT'</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'X-Custom-Header'</span>, <span class="string">'value'</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>上面代码中，HTTP请求的方法是<code>PUT</code>，并且发送一个自定义头信息<code>X-Custom-Header</code>。</p><p>浏览器发现，这是一个非简单请求，就自动发出一个“预测”请求，要求服务器确认可以这样请求。下面是这个“预测”请求的HTTP头信息。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPTIONS</span> <span class="string">/cors</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Origin</span>: http://api.bob.com</span><br><span class="line"><span class="attribute">Access-Control-Request-Method</span>: PUT</span><br><span class="line"><span class="attribute">Access-Control-Request-Headers</span>: X-Custom-Header</span><br><span class="line"><span class="attribute">Host</span>: api.alice.com</span><br><span class="line"><span class="attribute">Accept-Language</span>: en-US</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0...</span><br></pre></td></tr></table></figure><p>“预测”请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字是<code>Origin</code>，表示请求来自哪个源。</p><p>除了<code>Origin</code>字段，“预测”请求的头信息包括两个特殊字段。</p><h4 id="（1）Access-Control-Request-Method"><a href="#（1）Access-Control-Request-Method" class="headerlink" title="（1）Access-Control-Request-Method"></a>（1）Access-Control-Request-Method</h4><p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是<code>PUT</code>。</p><h4 id="（2）Access-Control-Request-Headers"><a href="#（2）Access-Control-Request-Headers" class="headerlink" title="（2）Access-Control-Request-Headers"></a>（2）Access-Control-Request-Headers</h4><p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例<code>X-Custom-Header</code>。</p><h3 id="4-2-预测请求的回应"><a href="#4-2-预测请求的回应" class="headerlink" title="4.2 预测请求的回应"></a>4.2 预测请求的回应</h3><p>服务器收到“预测”请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨域请求，回应。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span>: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line"><span class="attribute">Server</span>: Apache/2.0.61 (Unix)</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span>: http://api.bob.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span>: GET, POST, PUT</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span>: X-Custom-Header</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=utf-8</span><br><span class="line"><span class="attribute">Content-Encoding</span>: gzip</span><br><span class="line"><span class="attribute">Content-Length</span>: 0</span><br><span class="line"><span class="attribute">Keep-Alive</span>: timeout=2, max=100</span><br><span class="line"><span class="attribute">Connection</span>: Keep-Alive</span><br><span class="line"><span class="attribute">Content-Type</span>: text/plain</span><br></pre></td></tr></table></figure><p>上面的HTTP回应中，关键的是<code>Access-Control-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为<code>*</code>号，表示同意任意跨域资源。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span>: *</span><br></pre></td></tr></table></figure><p>如果浏览器否定了“预测”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息。这是，浏览器会认定，服务器不同预测请求，因此会触发一个错误<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获，控制台会打印出如下报错信息。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest cannot load http://api.alice.com.</span><br><span class="line">Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</span><br></pre></td></tr></table></figure><p>服务器回应的其他CORS相关字段如下。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Methods</span>: GET, POST, PUT</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span>: X-Custom-Header</span><br><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span>: true</span><br><span class="line"><span class="attribute">Access-Control-Max-Age</span>: 1728000</span><br></pre></td></tr></table></figure><h4 id="（1）Access-Control-Allow-Methods"><a href="#（1）Access-Control-Allow-Methods" class="headerlink" title="（1）Access-Control-Allow-Methods"></a>（1）Access-Control-Allow-Methods</h4><p>该字段必须，它的值是逗号分隔的一个字符串，表名服务器支持的跨域请求的方法，注意，返回的是所有支持的方法，而不是浏览器请求的那个方法。这是为了多次“预测”请求。</p><h4 id="（2）Access-Control-Allow-Headers"><a href="#（2）Access-Control-Allow-Headers" class="headerlink" title="（2）Access-Control-Allow-Headers"></a>（2）Access-Control-Allow-Headers</h4><p>如果浏览器请求包括<code>Access-Control-Request-Header</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必须的。它是一个逗号分隔的字符串，表名服务器支持的所有头信息字段，不限于浏览器在”预测“中请求的字段。</p><h4 id="（3）Access-Control-Allow-Credentials"><a href="#（3）Access-Control-Allow-Credentials" class="headerlink" title="（3）Access-Control-Allow-Credentials"></a>（3）Access-Control-Allow-Credentials</h4><p>该字段与简单请求时的含义相同。</p><h4 id="（4）Access-Control-Max-Age"><a href="#（4）Access-Control-Max-Age" class="headerlink" title="（4）Access-Control-Max-Age"></a>（4）Access-Control-Max-Age</h4><p>该字段可选，用来指定本次预检测请求的有效期，单位为秒。上面的结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间内，不用发出另一条预检测请求。</p><h3 id="4-3-浏览器的正常请求回应"><a href="#4-3-浏览器的正常请求回应" class="headerlink" title="4.3 浏览器的正常请求回应"></a>4.3 浏览器的正常请求回应</h3><p>一旦服务器通过了”预测“请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个<code>Origin</code>头信息字段。服务器回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PUT</span> <span class="string">/cors</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Origin</span>: http://api.bob.com</span><br><span class="line"><span class="attribute">Host</span>: api.alice.com</span><br><span class="line"><span class="attribute">X-Custom-Header</span>: value</span><br><span class="line"><span class="attribute">Accept-Language</span>: en-US</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0...</span><br></pre></td></tr></table></figure><p>下面是服务器的正常回应。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span>: http://api.bob.com</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><p>上面的头信息中，<code>Access-Control-Allow-Origin</code>字段是每次回应都必定包含的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载自阮一峰，链接：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/04/cors.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ruanyifeng.com/blog/2016/0
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CORS" scheme="http://yoursite.com/tags/CORS/"/>
    
      <category term="跨域" scheme="http://yoursite.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal详解</title>
    <link href="http://yoursite.com/2019/04/22/ThreadLocal%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/04/22/ThreadLocal详解/</id>
    <published>2019-04-22T11:18:08.000Z</published>
    <updated>2019-04-22T12:52:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal详解"><a href="#ThreadLocal详解" class="headerlink" title="ThreadLocal详解"></a>ThreadLocal详解</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>ThreadLocal类可以理解为线程本地变量。也就是说如果定义了一个ThreadLocal，每个线程往这个ThreadLocal中读写是线程隔离，互不影响的。它提供了一种将可变数据通过每个线程都有自己独立副本从而实现线程封闭机制。</p><h2 id="关于Thread类。"><a href="#关于Thread类。" class="headerlink" title="关于Thread类。"></a>关于Thread类。</h2><p>每一个线程都有一个Thread对象，这个对象有一些线程私有的变量和常量，比如线程ID，线程的状态，线程是否中断等等信息。而且在这里类里面有一个<code>threadLocals</code>变量，这个变量是一个<code>ThreadLocal.ThreadLocalMap</code>，这个类型是一个Map，这个Map中保存了这个线程所有的线程本地变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>key-value的形式存储，可以简单将ThreadLocal视为key，value为实际存放的值。之所以说是简单视为，是因为实际上ThreadLocal中存放的是ThreadLocal的弱引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">java</span>.<span class="title">lang</span>.<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 往ThreadLocal里实际塞入的值</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(java.lang.ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entry是ThreadLocalMap里定义的节点，它继承了WeakReference类，定义了一个类型为Object的value，用于存放放入ThreadLocal里的值。</p><h3 id="为何使用弱引用"><a href="#为何使用弱引用" class="headerlink" title="为何使用弱引用"></a>为何使用弱引用</h3><ul><li>如果使用普通的key-value形式来定义存储结构，实质上就会造成节点的生命周期与线程绑定，只要线程没有销毁，那么节点在GC可达性分析中一直处于可达状态，没有办法回收，而程序本身也无法判断是否可以清理节点。</li><li>弱引用是Java中四档引用的第三挡，比软引用更加弱一些，如果一个对象没有强引用链可达，那么一般活不过下一次GC。</li><li>当某个ThreadLocal已经没有强引用可达，则随着它被垃圾回收，在ThreadLocalMap里对应的Entry的建值会失效，这为ThreadLocalMap本身的垃圾清理提供了便利。</li></ul><h3 id="类成员变量与相应方法"><a href="#类成员变量与相应方法" class="headerlink" title="类成员变量与相应方法"></a>类成员变量与相应方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始容量，必须为2的幂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Entry表，大小必须为2的幂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表里entry的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重新分配表大小的阈值，默认为0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure><ul><li>ThreadLocalMap维护了一个Entry表或者说数组，并且要求表的大小为2的N次幂，同时记录表里面entry的个数以及下一次需要扩容的阈值。</li><li>为什么是2的N次幂。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置resize阈值以维持最坏2/3的装载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 环形意义的下一个索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 环形意义的上一个索引</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ThreadLocal需要维持一个最坏2/3的负载因子。</li><li>ThreadLocal中有两个方法用于得到上一个/下一个索引，这里实际上是环形意义的上一个与下一个。</li></ul><h4 id="由于ThreadLocalMap使用线程探测法来解决散列冲突，所以实际上Entry-数组在程序上是作为一个环形存在的。"><a href="#由于ThreadLocalMap使用线程探测法来解决散列冲突，所以实际上Entry-数组在程序上是作为一个环形存在的。" class="headerlink" title="由于ThreadLocalMap使用线程探测法来解决散列冲突，所以实际上Entry[]数组在程序上是作为一个环形存在的。"></a>由于ThreadLocalMap使用线程探测法来解决散列冲突，所以实际上Entry[]数组在程序上是作为一个环形存在的。</h4><h4 id="以下是ThreadLocalMap的内部存储结构："><a href="#以下是ThreadLocalMap的内部存储结构：" class="headerlink" title="以下是ThreadLocalMap的内部存储结构："></a>以下是ThreadLocalMap的内部存储结构：</h4><p><img src="http://m.qpic.cn/psb?/V13YqGLt33Wm0N/ydnbDqhkqk488E3M2ju3PNPNksQt8LQFRpBJRVvgUHY!/b/dDUBAAAAAAAA&amp;bo=lgVIAwAAAAADB*o!&amp;rf=viewer_4" alt="image"></p><p>ThreadLocalMap维护了Entry环形数组，数组元Entry的逻辑上的key为某个ThreadLocal对象（实际上是指向该ThreadLocal对象的弱引用），value为代码中该线程往ThreadLocal变量中放入的实际值。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个包含firstKey和firstValue的map。</span></span><br><span class="line"><span class="comment"> * ThreadLocalMap是惰性构造的，所以只有当至少要往里面放一个元素的时候才会构建它。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadLocalMap(java.lang.ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    <span class="comment">// 初始化table数组</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="comment">// 用firstKey的threadLocalHashCode与初始大小16取模得到哈希值</span></span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 初始化该节点</span></span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    <span class="comment">// 设置节点表大小为1</span></span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设定扩容阈值</span></span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个构造函数在set和get的时候都可能会被间接调用以初始化线程的ThreadLocalMap。</p><h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>ThreadLocal类中有一个被final修饰的类型为int的threadLocalHashCode，它在该ThreadLocal被构造的时候就会生成，相当于一个ThreadLocal的ID，它的值来源于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 生成hash code间隙为这个魔数，可以让生成出来的值或者说ThreadLocal的ID较为均匀地分布在2的幂大小的数组中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它是在上一个被构造出的ThreadLocal的ID/threadLocalHashCode的基础上在加上一个魔数0x61c88647的。这个魔数的选取与斐波那契散列有关，0x61c88647对应的十进制为1640531527.斐波那契散列的乘数可以用（long）（（1L&lt;&lt;31）*（Math.sqrt（5）- 1 ））可以得到2654435769，如果把这个值转为带符号的int，则会得到-1640531527.</p><ul><li>（（1L&lt;&lt;31）*（Math.sqrt（5）- 1 ））得到的结果就是1640531527也就是0x61c88647.当我们用0x61c88647作为魔数累加为每个ThreadLocal分配各自的ID也就是threadLocalHashCode再与2的幂取模，得到的结果分布很均匀。</li><li>ThreadLocalMap使用的是线性探测法，均匀分布的好处在于很快就能探测到下一个临近的可用点，从而保证效率。</li><li>大小取2的N次幂就是为了优化效率。</li></ul><p>下面我写了一段测试程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHashCodeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashCode = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= size; i++) &#123;</span><br><span class="line">            hashCode = i * HASH_INCREMENT;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(hashCode &amp; (size - <span class="number">1</span>))) &#123;</span><br><span class="line">                System.out.println(<span class="string">"重复"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(hashCode &amp; (size - <span class="number">1</span>));</span><br><span class="line">            System.out.print((hashCode &amp; (size - <span class="number">1</span>)) + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7 14 5 12 3 10 1 8 15 6 13 4 11 2 9 0</span><br><span class="line"></span><br><span class="line">7 14 21 28 3 10 17 24 31 6 13 20 27 2 9 16 23 30 5 12 19 26 1 8 15 22 29 4 11 18 25 0</span><br></pre></td></tr></table></figure><p>测试结果发现只是打印了每一个求\&amp;的结果，并没有打印出重复。所以说，可以通过这个魔数构造出一个完美散列，没有任何冲突。</p><h3 id="getEntry方法"><a href="#getEntry方法" class="headerlink" title="getEntry方法"></a>getEntry方法</h3><p>这个方法会被ThreadLocal的get方法直接调用，用于获取map中某个ThreadLocal存放的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据key这个ThreadLocal的ID来获取索引，也即哈希值</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="comment">// 对应的entry存在且未失效且弱引用指向的ThreadLocal就是key，则命中返回</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key) &#123;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 因为用的是线性探测，所以往后找还是有可能能够找到目标Entry的。</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 调用getEntry未直接命中的时候调用此方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于线性探测法不断向后探测直到遇到空entry。</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 找到目标</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 该entry对应的ThreadLocal已经被回收，调用expungeStaleEntry来清理无效的entry</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 环形意义下往后面走</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        &#125;</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个函数是ThreadLocal中核心清理函数，它做的事情很简单：</span></span><br><span class="line"><span class="comment"> * 就是从staleSlot开始遍历，将无效（弱引用指向对象被回收）清理，即对应entry中的value置为null，将指向这个entry的table[i]置为null，直到扫到空entry。</span></span><br><span class="line"><span class="comment"> * 另外，在过程中还会对非空的entry作rehash。</span></span><br><span class="line"><span class="comment"> * 可以说这个函数的作用就是从staleSlot开始清理连续段中的slot（断开强引用，rehash slot等）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为entry对应的ThreadLocal已经被回收，value设为null，显式断开强引用</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 显式设置该entry为null，以便垃圾回收</span></span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len); (e = tab[i]) != <span class="keyword">null</span>; i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 清理对应ThreadLocal已经被回收的entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 对于还没有被回收的情况，需要做一次rehash。</span></span><br><span class="line"><span class="comment">             * </span></span><br><span class="line"><span class="comment">             * 如果对应的ThreadLocal的ID对len取模出来的索引h不为当前位置i，</span></span><br><span class="line"><span class="comment">             * 则从h向后线性探测到第一个空的slot，把当前的entry给挪过去。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 在原代码的这里有句注释值得一提，原注释如下：</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line"><span class="comment">                 * null because multiple entries could have been stale.</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * 这段话提及了Knuth高德纳的著作TAOCP（《计算机程序设计艺术》）的6.4章节（散列）</span></span><br><span class="line"><span class="comment">                 * 中的R算法。R算法描述了如何从使用线性探测的散列表中删除一个元素。</span></span><br><span class="line"><span class="comment">                 * R算法维护了一个上次删除元素的index，当在非空连续段中扫到某个entry的哈希值取模后的索引</span></span><br><span class="line"><span class="comment">                 * 还没有遍历到时，会将该entry挪到index那个位置，并更新当前位置为新的index，</span></span><br><span class="line"><span class="comment">                 * 继续向后扫描直到遇到空的entry。</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * ThreadLocalMap因为使用了弱引用，所以其实每个slot的状态有三种也即</span></span><br><span class="line"><span class="comment">                 * 有效（value未回收），无效（value已回收），空（entry==null）。</span></span><br><span class="line"><span class="comment">                 * 正是因为ThreadLocalMap的entry有三种状态，所以不能完全套高德纳原书的R算法。</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * 因为expungeStaleEntry函数在扫描过程中还会对无效slot清理将之转为空slot，</span></span><br><span class="line"><span class="comment">                 * 如果直接套用R算法，可能会出现具有相同哈希值的entry之间断开（中间有空entry）。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                &#125;</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回staleSlot之后第一个空的slot索引</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读一个值可能遇到的情况："><a href="#读一个值可能遇到的情况：" class="headerlink" title="读一个值可能遇到的情况："></a>读一个值可能遇到的情况：</h4><h4 id="根据入参threadLcoal的threadLocalHashCode对表容量取模得到index"><a href="#根据入参threadLcoal的threadLocalHashCode对表容量取模得到index" class="headerlink" title="根据入参threadLcoal的threadLocalHashCode对表容量取模得到index"></a>根据入参threadLcoal的threadLocalHashCode对表容量取模得到index</h4><ul><li>如果index对应的slot就是要读的threadLocal，则直接返回结果。</li><li>调用getEntryAfterMiss线性探测，过程中碰到无效的slot，调用expungeStaleEntry进行段清理；如果找到了key，则返回结果entry；</li><li>没有找到key，返回null；</li></ul><h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 线性探测</span></span><br><span class="line">    <span class="comment">// 当hash有冲突的时候</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 找到对应的entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 替换失效的entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当没有冲突的时候直接放在桶中即可</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="comment">// 如果没有发现失效的值，并且当前容量大于阀值，那么做一个rehash</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) &#123;</span><br><span class="line">        rehash();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向前扫描，查找最前一个为空的位置</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="comment">// 向前扫描扫描到一个为空的位置    </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = prevIndex(i, len)) &#123;</span><br><span class="line">         <span class="comment">// 如果e.get() == null 那么这里是这个ThreadLcoal已经被回收，此时的这个key就失效了</span></span><br><span class="line">         <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向后遍历table</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到了key，将其与无效的slot交换</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            <span class="comment">// 更新对应slot的value值</span></span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 交换，将它和前面的空的交换</span></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果在向前扫描的过程中遇见了一个是失效的key，那么slotTOExpunge会被改变</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot) &#123;</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从slotToExpunge开始做一次连续段的清理，再做一次启发式清理</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前的值是一个已经失效的值，并且向前扫描的时候没有发现失效的值，那么把过期需要擦除的位置设置为当前的位置i</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot) &#123;</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果key在table中不存在，则在原地放一个即可</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在探测过程中如果发现任何无效slot，则做一次清理（连续段清理+启发式清理）</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot) &#123;</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    <span class="comment">// 擦除staleSolt位置的Entry</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    <span class="comment">// 重新hash直到遇到null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 遇到失效的值，然后就把这个失效的值清理掉</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不是失效的值，那么重新做运算获取索引</span></span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 如果不是当前位置</span></span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">            <span class="comment">// 把当前位置置空</span></span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="comment">// 重新找下一个为空的位置</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里返回的i既不是null，也不是一个失效的值</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启发式地清理slot,</span></span><br><span class="line"><span class="comment"> * i对应entry是非无效（指向的ThreadLocal没被回收，或者entry本身为空）</span></span><br><span class="line"><span class="comment"> * n是用于控制控制扫描次数的</span></span><br><span class="line"><span class="comment"> * 正常情况下如果log n次扫描没有发现无效slot，函数就结束了</span></span><br><span class="line"><span class="comment"> * 但是如果发现了无效的slot，将n置为table的长度len，做一次连续段的清理</span></span><br><span class="line"><span class="comment"> * 再从下一个空的slot开始继续扫描</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个函数有两处地方会被调用，一处是插入的时候可能会被调用，另外个是在替换无效slot的时候可能会被调用，</span></span><br><span class="line"><span class="comment"> * 区别是前者传入的n为元素个数，后者为table的容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// 每右移一次相当于降了一个2次幂，所以这里总共会循环x次，x是2^x = n</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// i在任何情况下自己都不会是一个无效slot，所以从下一个开始判断</span></span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        Entry e = tab[i];</span><br><span class="line">        <span class="comment">// 如果当前的位置是一个失效的值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 扩大扫描控制因子</span></span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 清理一个连续段</span></span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果发现了失效的值，返回true，否则返回false</span></span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 做一次全量清理，在全部清理的过程中进行rehash</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 因为做了一次清理，所以size很可能会变小。</span></span><br><span class="line"><span class="comment">     * ThreadLocalMap这里的实现是调低阈值来判断是否需要扩容，</span></span><br><span class="line"><span class="comment">     * threshold默认为len*2/3，所以这里的threshold - threshold / 4相当于len/2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>) &#123;</span><br><span class="line">        resize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 做一次全量清理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 清理当前的值，并且做一个rehash</span></span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容，因为需要保证table的容量len为2的幂，所以扩容即扩大2倍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 线性探测来存放Entry</span></span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                &#125;</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set方法可能会遇到的情况"><a href="#set方法可能会遇到的情况" class="headerlink" title="set方法可能会遇到的情况"></a>set方法可能会遇到的情况</h4><ul><li>探测过程中slot都不无效，并且顺利找到key所在的slot，直接替换即可。</li><li><p>探测过程中发现有无效slot，调用replaceStaleEntry，效果是最终一定会把key和value放这个slot，并且会尽可能清理无效slot</p><ul><li>在replaceStaleEntry过程中，如果找到了key，则做一个swap把它放到那个无效slot中，value置为新值；</li><li>在replaceStaleEntry过程中，没有找到key，直接在无效slot原地放entry。</li></ul></li><li><p>探测没有发现key，则在连续段末尾的后一个空位置上放entry，这也是线性探测法的一部分。放完后，做一次启发式清理，如果没有清理出去key，并且当前table大小已经超过阈值了，则做一次rehash，rehash函数会调用一次全量清理slot方法也就是expungeStaleEntries，如果完了之后table大小超过了threshold-threshold/4，则进行扩容2倍。</p></li></ul><h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从map中删除ThreadLocal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            <span class="comment">// 显式断开弱引用</span></span><br><span class="line">            e.clear();</span><br><span class="line">            <span class="comment">// 进行段清理，并且做一个rehash</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remove方法直接在table中找key，如果找到了，把弱引用断了做一次段清理。</p><h2 id="ThreadLocal与内存泄漏"><a href="#ThreadLocal与内存泄漏" class="headerlink" title="ThreadLocal与内存泄漏"></a>ThreadLocal与内存泄漏</h2><ul><li>关于ThreadLocal是否会引起内存泄漏也是一个比较有争议的问题，其实主要看对内存泄漏的准确定义是什么。</li><li>认为ThreadLocal会引起内存泄漏的说法是因为如果一个ThreadLocal对象被回收了，我们往里面放的value对于【当前线程-&gt;当前线程的threadLocals（ThreadLocal.ThreadLocalMap对象）-&gt;Entry数组-&gt;某个entry.value】这样一条强引用链是可达的，因此value不会被回收。</li><li>认为ThreadLocal不会引起内存泄漏的说法是因为ThreadLocal.ThreadLocalMap源码实现中自带一套清理机制。</li><li>每个thread中都存在一个map，map的类型是ThreadLocal.ThreadLocalMap。Map中的key为一个thread实例，这个Map的确使用了弱引用，不过弱引用只是针对key，每个key都弱引用指向threadlocal。当把threadlocal实例置为null以后，没有任何强引用指向threadlocal实例，所以threadlocal将会被GC回收，但是，我们的value却不能被回收，因为存在一条从current thread连接过来的强引用，只有当前thread结束后，current thread就不会存在栈中，强引用断开，Current Thread，Map，Value将会被GC回收。</li><li>所以说只要线程对象被回收就不会发生内存泄漏，但是在threalLocal设为null到线程结束这段时间就不会被回收，就发生了所谓的内存泄漏。</li><li>最严重的就是线程对象不被回收的情况，这就发生了真正意义上的内存泄漏，比如使用线程池的时候，线程结束是不会销毁的，会再次使用，就可能出现内存泄漏。</li><li>Java为了最小化减少内存泄漏的可能性和影响，在ThreadLocal的get，set的时候都会清除线程Map里所有的key为null的value。所以最坏的情况就是，threadLocal对象设为null了，开始发生“内存泄漏”，然后使用线程池，这个线程结束，线程放回线程池不销毁，这个线程池一直不被使用，或者分配了又不再调用get，set方法，这个期间就会发生真正的内存泄漏，所以建议在使用ThreadLocal手动的调用<code>remove()</code>方法。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ThreadLocal类可以理解为线程本地变量。也就是说如果定义了一个ThreadLocal，每个线程往这个ThreadLocal中读写是线程隔离，互不影响的。它提供了一种将可变数据通过每个线程都有自己独立副本从而实现线程封闭机制。</p><p>在ThreadLocal中有一个ThreadLocalMap，这个ThreadLocalMap也是一个Map，它的键值是一个ThreadLocal，值是定义的本地线程变量。前面提到了ThreadLocal是一个线程本地变量，这是因为在Thread类中有一个ThreadLocalMap的对象，当前线程中的ThreadLocal对象会被存储在这个ThreadLocalMap对象中。</p><p>ThreadLocalMap中的Entry继承了WeakReference，并将ThreadLocal对象设置为弱引用，因为如果当对象中的ThreadLocal对象被设置为空的时候，这个ThreadLocal对象还会被ThreadLocalMap中有一个引用，所以这个对象会被判定是可达的，所以GC不会将这个对象回收，所以就必定会产生内存泄露。因此在这里使用了弱引用。</p><p>ThreadLocalMap和HashMap以及Hashtable不同的是ThreadLocalMap使用的Hash算法是<strong>线性探测再散列</strong>。这里使用的线性探测再散列的方法是如果出现了Hash冲突，然后就找下一个，这里值得注意的一点是它把hash桶设置为一个环，也就是说最后一个元素的下一个元素是第一个元素。</p><p>ThreadLocal中有一套自带的清理机制，在get和set的时候都会进行一次无效值清理。在get的时候首先使用和HashMap中相同的通过hash计算索引的方式进行计算，将hash桶中的该位置的key和传入的ThreadLocal对象做比较如果相等，那么然后，如果不相等，继续向下找，如果在找的过程中发现了无效的值，那么从失效值的位置开始进行一次清理，并且进行rehash。set的时候也是类似，不过在set的时候会进行resize，将ThreadLocalMap进行扩容，扩容的时候是将原来的hash桶扩大一倍，然后重新计算位置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ThreadLocal详解&quot;&gt;&lt;a href=&quot;#ThreadLocal详解&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal详解&quot;&gt;&lt;/a&gt;ThreadLocal详解&lt;/h1&gt;&lt;h2 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; cla
      
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="ThreadLocal" scheme="http://yoursite.com/tags/ThreadLocal/"/>
    
      <category term="线程封闭" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E5%B0%81%E9%97%AD/"/>
    
  </entry>
  
  <entry>
    <title>线程池详解.md</title>
    <link href="http://yoursite.com/2019/04/16/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3-md/"/>
    <id>http://yoursite.com/2019/04/16/线程池详解-md/</id>
    <published>2019-04-16T14:02:39.000Z</published>
    <updated>2019-04-16T14:15:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="线程池实现原理"><a href="#线程池实现原理" class="headerlink" title="线程池实现原理"></a>线程池实现原理</h2><p>当向线程池中提交任务之后，线程池是如何处理这个任务的呢？我们先来看看线程池的主要处理流程，处理流程如下图：</p><p>从图中可以看出，当提交一个新任务到线程池时，线程池的处理流程如下。</p><ol><li>线程池判断核心线程数是否都在执行。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里面的线程都在执行任务。则进入下一个流程。</li><li>线程池判断工作队列是否已经满。如果工作队列没有慢，则将新提交的任务存储在这个工作队列中。如果工作队列满了，则进入下一个流程。</li><li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的线程来执行任务，如果已经满了，则交给饱和策略来处理这个任务。</li></ol><p>ThreadPoolExecutor执行execute()方法的示意图，如下图所示：</p><p><img src="http://static.zybuluo.com/Rico123/hn3kntnedu8bi707rb6szzmf/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.jpg" alt="线程池的处理流程"></p><p><img src="https://img-blog.csdn.net/20160510121421091" alt="ThreadPoolExecutor执行示意图"></p><ol><li>如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）。</li><li>运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</li><li>如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，这一执行步骤需要获取全局锁）。</li><li>如果创建新线程将使当前运行的线程超出了maximumPoolSize，任务将被拒绝，并调用<code>RejectedExecutionHandler.rejectedExecution()</code>方法。</li></ol><p>ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行<code>execute()</code>方法时，尽可能的避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。在ThreadPoolExecutorw完成预热之后（当前运行的线程数大于等于corePoolSize），几乎所有的<code>execute()</code>方法调用都是执行步骤2，而步骤2不需要获取全局锁。</p><p>下面我们来通过源码分析ThreadPoolExecutor的工作原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 如果线程的数量小于基本线程数，则创建线程并执行当前任务</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 这里重新获取线程池状态</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// 重新检查线程池状态</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line"><span class="comment">// 这里进行重新检测</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果无法放入阻塞队列中，尝试再次创建线程运行，如果失败了，则执行拒绝逻辑</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作线程：线程池创建线程时，会将线程封装成工作线程Worker,Worker在执行人任务后，还会循环获取工作队列里的任务来执行。我们可以从Worker类的run()f方法里看到这点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 这里通过循环从阻塞队列里面获取任务来执行</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">    <span class="comment">// 如果线程池停止，请确保线程被中断</span></span><br><span class="line">    <span class="comment">// 如果没有，请确保线程没有被中断。这里需要在第二种情况下重新检查才能处理</span></span><br><span class="line">    <span class="comment">// 以便在清除中断的同时处理立即关闭比赛</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                    afterExecute(task, <span class="keyword">null</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    afterExecute(task, ex);</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor中线程执行任务的示意图如下所示：</p><p><img src="http://img.blog.csdn.net/20160221172500424" alt="ThreadPoolExecutor执行示意图"></p><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><p>我们可以通过<code>ThreadPoolExecutor</code>来创建一个线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><p>我们创建一个线程池时要输入几个参数，如下：</p><ol><li>corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于基本线程的时候就不在创建了。如果调用了线程池的<code>prestartAllCoreThreads()</code>方法，线程池会提前创建并启动所有基本线程。</li><li>runableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列，可以选择一下几个阻塞队列。<ul><li>ArrayBlockingQueue：是一个基于数组结构的有界队列，此队列按FIFO（先进先出）原则对元素进行排序。</li><li>LinkedBlockingQueue：一个基于链表的阻塞队列。此队列按照FIFO排列元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到一个线程调用移出操作，否则一个插入操作一直处于阻塞状态，吞吐量通常高于LinkedBlockingQueue，静态工厂Executors.newCachedThreadPool使用了这个队列。</li><li>PriorityBlockingQueue：一个具有优先级的无界阻塞队列。</li></ul></li><li>maximumPoolSize（线程池的最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已经创建的线程数小于最大线程数，则线程池会在创建新的线程执行任务。值得注意的是，如果使用了无界的阻塞队列这个参数就没有任何意义。</li><li>ThreadFactory：用于设置创建线程的工厂，可以通过这个线程工厂给每个创建出来的线程设置更有意义的名字。</li><li><p>RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认的情况是<code>AbortPolicy</code>，表示无法处理新任务时抛出的异常。在JDK中提供了以下4中策略。</p><ul><li><code>AbortPolicy</code>：抛出异常。</li><li><code>CallerRunsPolicy</code>：只用调用者所在线程来运行任务。</li><li><code>DiscardOldestPolicy</code>：丢弃任务队列里面最近的一个任务，并执行当前的任务。</li><li><code>DiscardPolicy</code>: 不处理，丢弃掉。<br>当然也可以根据应用场景来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化存储不能处理的任务。</li></ul></li><li><p>keepAliveTime（线程活动保持时间）：线程池的工作空闲后，保持存货时间。所以，如果任务很多，并且每个任务执行很短，则可以调大时间，提交线程的利用率。这个线程活动保持时间指定不是核心线程，而是除了核心线程外的线程。核心线程一般会一直存货。</p></li><li>TimeUnit（线程活动保持时间的单位）。</li></ol><h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>可以使用两个方法向线程池提交任务，分别为<code>execute()</code>和<code>submit()</code>方法。</p><p><code>execute()</code>方法用与提交不需要返回值的任务，所以无法判断是否被线程执行成功。通过下一代码可知execute()方法输入的任务是一个Runnable的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个<code>Future</code>类型的对象，通过这个<code>Future</code>对象可以判断任务是否执行完成，而使用<code>get(long timeout, TimeUnit unit)</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> MyCallable());</span><br><span class="line">log.info(<span class="string">"do something in main"</span>);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">String s = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    s = future.get(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>可以通过调用线程池的<code>shutdown</code>或<code>shutdownNow</code>方法来关闭线程池，它们的原理是遍历池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务将永远无法终止。但是它们有一定的区别，<code>shutdownNow</code>首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停执行任务的线程，并返回等待任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</p><p>只要调用了着两个关闭方法中的任意一个，<code>isShutdown</code>方法就会返回true。当所有的任务都已经关闭后，才表示线程池关闭成功，这时调用<code>isTermined</code>方法就会返回true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用<code>shutdown</code>方法来关闭线程池，如果任务不一定要执行完，则可以调用<code>shutdownNow</code>方法。</p><h3 id="合理配置线程池"><a href="#合理配置线程池" class="headerlink" title="合理配置线程池"></a>合理配置线程池</h3><p>想要合理配置线程池，就必须要分析任务特性，可以从以下几个角度来分析。</p><ul><li>任务性质：CPU密集性、IO密集型和混合任务。</li><li>任务的优先级：高、中、低。</li><li>任务的执行时间：长、中、短。</li><li>任务的依赖性：是否依赖其他系统资源，如数据库连接。</li></ul><p>性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务应该配置尽可能小的线程，如配置 $N_{cpu}+1$个线程的线程池。由于IO密集型任务线程并不是一直执行任务，则应配置尽可能多的线程。如 $2*N_{cpu}$。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型和IO密集型任务，这要这两个任务执行时间相差不是太大，则没有必要进行分解。可以通过<code>Runtime.getRuntime().availableProcessor()</code>方法获取当前设备的CPU数量。</p><p>优先级不同的任务可以使用优先级队列<code>PriorityBlockingQueue</code>来处理。他可以让优先级高的任务先执行。</p><p>注意：<strong>如果一直有高优先级的任务提交到队列里，那么优先级低的任务可能永远不能执行</strong>。</p><p>执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先队列，让线程执行短的任务先执行。</p><p>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，等待的时间越长，则CPU空闲时间也就越长，那么线程数就应该设置的越大，这样才能更好的利用CPU。</p><p><strong>建议使用有界队列</strong>。有界队列能增加系统的稳定性和预警能力，可以根据需要设置大一点儿，比如几千。因为无界队列的容量是无限的可能任务一多可能会出现OOM的异常。</p><h3 id="线程池监控"><a href="#线程池监控" class="headerlink" title="线程池监控"></a>线程池监控</h3><p>如果在系统中大量使用线程池，则有必要对线程池进行监控，方便在出现问题时，可以根据线程池的使用状况快速定位问题。可以通过线程池提交的参数进行监控，在监控线程池的时候可以使用以下属性。</p><ul><li>taskCount：线程池需要执行的任务数量。</li><li>completedTaskCount：线程池在运行刚欧城中已完成的任务数量，小于或等于taskCount。</li><li>largestPoolSize：线程池里曾经创建过的最大的线程数量。通过这个数据就可以知道线程池是否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。</li><li>getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池中的线程不会自动销毁，所以这个大小只增不减。</li><li>getActivityCount：获取活动的线程数。</li></ul><p>通过扩展线程池进行监控。可以通过继承线程池来自定义线程池，重写线程池的<code>beforeExecute</code>、<code>afterExecute</code>和<code>terminated</code>方法，也可以在任务执行前、执行后和线程池关闭前执行一些代码来进行监控。例如，线程任务的平均执行时间、最大执行时间和最小关闭时间等。这几个方法在线程池里是空方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程池&quot;&gt;&lt;a href=&quot;#线程池&quot; class=&quot;headerlink&quot; title=&quot;线程池&quot;&gt;&lt;/a&gt;线程池&lt;/h1&gt;&lt;h2 id=&quot;线程池实现原理&quot;&gt;&lt;a href=&quot;#线程池实现原理&quot; class=&quot;headerlink&quot; title=&quot;线程池实现原理
      
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="JUC" scheme="http://yoursite.com/tags/JUC/"/>
    
      <category term="线程池" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="Executor" scheme="http://yoursite.com/tags/Executor/"/>
    
      <category term="ThreadPoolExecutor" scheme="http://yoursite.com/tags/ThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>Java中的阻塞队列</title>
    <link href="http://yoursite.com/2019/04/14/Java%E4%B8%AD%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/04/14/Java中的阻塞队列/</id>
    <published>2019-04-14T12:55:07.000Z</published>
    <updated>2019-04-14T12:57:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中的阻塞队列"><a href="#Java中的阻塞队列" class="headerlink" title="Java中的阻塞队列"></a>Java中的阻塞队列</h1><p>阻塞队列（Blocking Queue）是一个支持两个附加操作的队列。这两个附加操作支持阻塞的插入和移除方法。</p><ol><li>支持阻塞的插入方法，意思是当队列满时，队列会阻塞插入元素的线程，知道队列不满。</li><li>支持阻塞移出的方法：意思是在队列为空时，获取元素的线程对等待队列变为非空。</li></ol><p>阻塞队列常用于生产者消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。</p><p>在阻塞队列不可用时，这两个附加操作提供了四种处理方式：</p><table><thead><tr><th style="text-align:center">方法/处理方式</th><th style="text-align:center">抛出方式</th><th style="text-align:center">返回特殊值</th><th style="text-align:center">一直阻塞</th><th style="text-align:center">超时退出</th></tr></thead><tbody><tr><td style="text-align:center">插入方法</td><td style="text-align:center">add(e)</td><td style="text-align:center">offer(e)</td><td style="text-align:center">put(e)</td><td style="text-align:center">offer(e, time, unit)</td></tr><tr><td style="text-align:center">移出方法</td><td style="text-align:center">remove()</td><td style="text-align:center">poll()</td><td style="text-align:center">take()</td><td style="text-align:center">put(time, out)</td></tr><tr><td style="text-align:center">检查方法</td><td style="text-align:center">element()</td><td style="text-align:center">peek()</td><td style="text-align:center">不可用</td><td style="text-align:center">不可用</td><td style="text-align:center">不可用</td></tr></tbody></table><ul><li>抛出异常：当队列满时，如果再往队列里面插入元素，就会抛出<code>IllegalStateException(&quot;Queue full&quot;)</code>异常。当队列空时，从队列中获取元素会抛出<code>NoSuchElementException</code>异常。</li><li>返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移出方法，则是从队列里取出一个元素，如果没有则返回null。</li><li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里面put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列为空时，如果消费者从队列里面take元素，队列会阻塞住消费者线程，直到队列不为空。</li></ul><p>注意：<strong>如果是无界阻塞队列，队列不可能会出现满了的情况，所以使用put和offer方法永远不会被阻塞，而是使用offer方法时，该方法永远返回true。</strong></p><p>阻塞队列对应</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回特殊值</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞，可中断</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时退出</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞，可中断</span></span><br><span class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回特殊值，也就是删除的对象</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩余的容量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除 抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否包含</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从该队列中删除可用元素，并将它们添加到给定集合中。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从该队列中删除maxElements可用元素，并将它们添加到给定集合中。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java里的阻塞队列"><a href="#Java里的阻塞队列" class="headerlink" title="Java里的阻塞队列"></a>Java里的阻塞队列</h2><p>JDK提供了7个阻塞队列，如下：</p><ul><li>ArrayBlockingQueue：一个由数组构成的有界阻塞队列。</li><li>LinkedBlockingQueue：一个由链表组成的有界阻塞队列。</li><li>PriorityBlockingQueue：一个支持优先级排列的无界阻塞队列。</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li></ul><h3 id="1-ArrayBlockingQueue"><a href="#1-ArrayBlockingQueue" class="headerlink" title="1. ArrayBlockingQueue"></a>1. ArrayBlockingQueue</h3><p>ArrayBlockingQueue是一个数组实现的有界队列。此队列按照先进先出（FIFO）的原则对元素进行排序。</p><p>下面的是一个ArrayBlockingQueue的一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueueExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayBlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 放入10个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            log.info(<span class="string">"往阻塞队列中放入：&#123;&#125;"</span>, i);</span><br><span class="line">            blockingQueue.put(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (blockingQueue.remainingCapacity() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"阻塞队列中没有空间了"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"阻塞队列中的剩余空间：&#123;&#125;"</span>, blockingQueue.remainingCapacity());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                Integer take = blockingQueue.take();</span><br><span class="line">                log.info(<span class="string">"从阻塞队列中取出一个数据：&#123;&#125;"</span>, take);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        log.info(<span class="string">"往阻塞队列插入一个数据"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            blockingQueue.add(<span class="number">11</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            log.info(<span class="string">"往阻塞队列中插入（add）数据的时候发生异常：&#123;&#125;"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> offer = blockingQueue.offer(<span class="number">11</span>);</span><br><span class="line">        log.info(<span class="string">"往阻塞队列中插入(offer)数据的时候，返回一个特殊值，&#123;&#125;"</span>, offer);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"往阻塞队列中插入(put)数据的时候，一直阻塞"</span>);</span><br><span class="line">        blockingQueue.put(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Integer take = blockingQueue.take();</span><br><span class="line">            log.info(<span class="string">"从阻塞队列中取出一个元素：&#123;&#125;"</span>, take);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下不保证线程公平的访问队列，所谓公平访问是指阻塞的线程，可以按照队列阻塞的先后顺序访问队列，即先阻塞线程先访问队列。非公平性是对等待的线程是非公平的，如果有一个线程刚好在队列可用的时候调用了take()方法，那么可能调用<code>take()</code>方法的线程会插队到等待队列中的第一个节点的前面。为了保证公平性，通常会降低吞吐量。我们可以使用一下代码创建一个非公平的阻塞队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>访问者的公平锁是通过可重入锁实现的，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>ArrayBlockingQueue</code>是通过<code>ReentrantLock</code>可重入锁和这个可重入锁的两个等待的<code>Condition</code>队列，<code>notEmpty</code>和<code>notFull</code>实现的。</p><p>下面来看看它的put和take方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Objects.requireNonNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 队列满了的时候进入notFull等待队列</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 队列为空的时候进入notEmpty等待队列</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-LinkedBlockingQueue"><a href="#2-LinkedBlockingQueue" class="headerlink" title="2. LinkedBlockingQueue"></a>2. LinkedBlockingQueue</h3><p><code>LinkedBlockingQueue</code>是一个基于链表的实现的有界队列。此队列的默认最大长度为<code>Integer.MAX_VALUE</code>。此队列按照先进先出的顺序对元素进行排序。</p><p><code>LinkedBlockingQueue</code>的示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedBlockingQueueExample</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LinkedBlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 放入10个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            log.info(<span class="string">"往阻塞队列中放入：&#123;&#125;"</span>, i);</span><br><span class="line">            blockingQueue.put(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (blockingQueue.remainingCapacity() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"阻塞队列中没有空间了"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"阻塞队列中的剩余空间：&#123;&#125;"</span>, blockingQueue.remainingCapacity());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                Integer take = blockingQueue.take();</span><br><span class="line">                log.info(<span class="string">"从阻塞队列中取出一个数据：&#123;&#125;"</span>, take);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        log.info(<span class="string">"往阻塞队列插入一个数据"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            blockingQueue.add(<span class="number">11</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            log.info(<span class="string">"往阻塞队列中插入（add）数据的时候发生异常：&#123;&#125;"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> offer = blockingQueue.offer(<span class="number">11</span>);</span><br><span class="line">        log.info(<span class="string">"往阻塞队列中插入(offer)数据的时候，返回一个特殊值，&#123;&#125;"</span>, offer);</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"往阻塞队列中插入(put)数据的时候，一直阻塞"</span>);</span><br><span class="line">        blockingQueue.put(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Integer take = blockingQueue.take();</span><br><span class="line">            log.info(<span class="string">"从阻塞队列中取出一个元素：&#123;&#125;"</span>, take);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedBlockingQueue是通过两个<code>ReentrantLock</code>，以及这两个<code>ReentrantLock</code>的等待队列<code>Condition</code>，以及一个<code>AtomicInteger</code>实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Current number of elements */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure><p>下面我们来看看它的具体的put方法和take方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(node);</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果c == 0唤醒notEmpty等待队列上等待的线程。</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> E x;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里使用了两个锁，一个用于生产一个消费，因为生产在链表的一端，而消费在链表的另一端，操作互不影响。</p><h3 id="3-PriorityBlockingQueue"><a href="#3-PriorityBlockingQueue" class="headerlink" title="3. PriorityBlockingQueue"></a>3. PriorityBlockingQueue</h3><p><code>PriorityBlockingQueue</code>是一个支持优先级的无界阻塞队列，默认情况下采用自然顺序升序排列。也可以自定义类实现<code>Comparable</code>接口来指定元素的排序规则。或者初始化<code>PriorityBlockingQueue</code>时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p><p>优先队列因为是无界的，所以不会出现元素已经满了的情况，只会出现元素空了的情况，所以优先队列的实现只用了一个<code>ReentrantLock</code>和它的等待队列<code>notEmpty</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Condition for blocking when empty.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br></pre></td></tr></table></figure><p>具体在插入和删除的时候用到了优先队列，也就是堆排序的思想。在这里不做讨论。</p><h3 id="4-DelayQueue"><a href="#4-DelayQueue" class="headerlink" title="4. DelayQueue"></a>4. DelayQueue</h3><p><code>DelayQueue</code>是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建的时候才可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。</p><p>DelayQueue非常有用，可以将DelayQueue运用在如下的场景。</p><ul><li>缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程来循环查询DelayQueue，一旦能从DelayQueue获取元素，表示缓存有效期到了。</li><li>定时任务调度：使用DelayQueue保存当天将会执行的任务和时间，一旦从DelayQueue中获取到任务就开始执行，比如<code>TimerQueue</code>就是使用DelayQueue实现的。</li></ul><h4 id="1-如何实现Delay接口"><a href="#1-如何实现Delay接口" class="headerlink" title="1. 如何实现Delay接口"></a>1. 如何实现Delay接口</h4><p>DelayQueue队列的元素必须实现Delay接口。我们可以参考<code>ScheduledThreadPoolExecutor</code>里的<code>ScheduleFutureTask</code>类的实现，一共有三步。</p><p>第一步：在创建对象的时候，初始化基本数据。使用time记录当前对象延迟到什么时候可以使用，使用sequenceNumber标识元素在队列中的先后顺序。如下代码所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Sequence number to break ties FIFO */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceNumber;</span><br><span class="line"><span class="comment">/** The nanoTime-based time when the task is enabled to execute. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> time;</span><br><span class="line"></span><br><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> triggerTime,</span><br><span class="line">                    <span class="keyword">long</span> sequenceNumber) &#123;</span><br><span class="line">    <span class="keyword">super</span>(r, result);</span><br><span class="line">    <span class="keyword">this</span>.time = triggerTime;</span><br><span class="line">    <span class="keyword">this</span>.period = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequenceNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：实现getDelay方法，该方法返回当前元素还需要延时多长时间，单位是纳秒，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unit.convert(time - System.nanoTime(), NANOSECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的延时时间triggerTime为纳秒，自己设计的时候最好使用纳秒，因为实现getDelay()方法时可以指定任意单位，一旦以秒作为单位，而延时时间又精确不到纳秒就麻烦了。使用时请注意当time小于当前时间单位的时，getDelay会返回负数。</p><p>第三步：实现compareTo方法来指定元素的顺序。例如，让延时时间最长的放在队列的末尾。实现代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (other == <span class="keyword">this</span>) <span class="comment">// compare zero if same object</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (other <span class="keyword">instanceof</span> ScheduledFutureTask) &#123;</span><br><span class="line">        ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;</span><br><span class="line">        <span class="keyword">long</span> diff = time - x.time;</span><br><span class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);</span><br><span class="line">    <span class="keyword">return</span> (diff &lt; <span class="number">0</span>) ? -<span class="number">1</span> : (diff &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-如何实现延时阻塞队列"><a href="#2-如何实现延时阻塞队列" class="headerlink" title="2. 如何实现延时阻塞队列"></a>2. 如何实现延时阻塞队列</h4><p>延时阻塞队列的实现非常简单，当消费者从队列里面去元素的时候，如果没有元素达到延时时间，就阻塞当前线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            E first = q.peek();</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> q.poll();</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的变量leader是一个等待获取队列头部元素的线程。如果leader不等于空，表示已经有线程在等待获取队列的头元素。所以，使用<code>await()</code>方法让当前线程等待信号。如果leader等于空，则把当前线程设置成leader，并使用<code>awaitNanos()</code>方法让当前线程接收信号或等待delay时间。</p><p>一个简单的<code>DelayQueue</code>的demo。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDelayedClass</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyDelayedClass</span><span class="params">(<span class="keyword">long</span> time, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.time = System.nanoTime() + time;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> unit.convert(time - System.nanoTime(), TimeUnit.NANOSECONDS);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> MyDelayedClass) &#123;</span><br><span class="line">                MyDelayedClass x = (MyDelayedClass) o;</span><br><span class="line">                <span class="keyword">long</span> diff = time - x.time;</span><br><span class="line">                <span class="keyword">if</span> (diff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> diff = getDelay(TimeUnit.NANOSECONDS) - o.getDelay(TimeUnit.NANOSECONDS);</span><br><span class="line">            <span class="keyword">return</span> (diff &lt; <span class="number">0</span>) ? -<span class="number">1</span> : (diff &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DelayQueue&lt;MyDelayedClass&gt; delayQueue = <span class="keyword">new</span> DelayQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            delayQueue.put(<span class="keyword">new</span> MyDelayedClass(TimeUnit.NANOSECONDS.convert((i + <span class="number">1</span>) * <span class="number">10</span>, TimeUnit.SECONDS), i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            log.info(<span class="string">"从DelayQueue中获取元素，时间为：&#123;&#125;"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">            MyDelayedClass take = delayQueue.take();</span><br><span class="line">            log.info(<span class="string">"从DelayQueue中获取元素成功，时间为：&#123;&#125;"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-SynchronousQueue"><a href="#5-SynchronousQueue" class="headerlink" title="5. SynchronousQueue"></a>5. SynchronousQueue</h4><p><code>SynchronousQueue</code>是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。</p><p>它支持公平访问队列。默认情况下采用非公平性策略访问队列。使用如下构造器可以创建一个公平访问的<code>SynchronousQueue</code>，如果设置为true，则等待的线程会采用先进先出的顺序访问队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    transferer = fair ? <span class="keyword">new</span> TransferQueue&lt;E&gt;() : <span class="keyword">new</span> TransferStack&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SynchronousQueue</code>可以看成一个传球手，负责把生产的线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合传递性场景。<code>SynchronousQueue</code>的吞吐量高于<code>LinkedBlockingQueue</code>和<code>ArrayBlockingQueue</code>。</p><h4 id="6-LinkedTransferQueue"><a href="#6-LinkedTransferQueue" class="headerlink" title="6. LinkedTransferQueue"></a>6. LinkedTransferQueue</h4><p>LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedQueue多了tryTransfer和transfer方法。</p><ol><li><p>transfer方法</p><p> 如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素放在队列的tail节点，并等待该元素被消费者消费才返回。</p></li><li><p>tryTransfer方法</p><p> tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则直接返回flase。和transfer方法的区别是tryTransfer方法无论是消费者是否接收，方法立即返回，而transfer方法是必须等到消费者消费了才返回。</p><p> 对于带有时间限制的<code>tryTransfer(E e, long timeout, TimeUnit unit)</code>方法，试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间在返回，如果超时还没有消费，则返回false，如果在超时时间内消费了该元素，则返回true。</p></li></ol><h3 id="7-LinkedBlockingDequeue"><a href="#7-LinkedBlockingDequeue" class="headerlink" title="7. LinkedBlockingDequeue"></a>7. LinkedBlockingDequeue</h3><p>LinkedBlockingDequeue是一个由链表结构组成的双向阻塞队列。所谓双向阻塞队列。所谓双向阻塞队列指的是可以从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，<code>LinkedBlockingDeque</code>多了<code>addFirst</code>、<code>addLast</code>、<code>offerLast</code>、<code>peekFirst</code>、<code>peekLast</code>等方法，以First单词结尾的方法，表示插入、获取或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入、获取或移除双端队列的最后一个元素，另外，插入方法<code>add</code>等同于<code>addLast</code>，移除方法<code>remove</code>等效于<code>removeFirst</code>。但是<code>take</code>方法却等同于<code>takeFirst</code>。</p><p>在初始化<code>LinkedBlockingDeque</code>时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在<code>工作窃取</code>模式中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java中的阻塞队列&quot;&gt;&lt;a href=&quot;#Java中的阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;Java中的阻塞队列&quot;&gt;&lt;/a&gt;Java中的阻塞队列&lt;/h1&gt;&lt;p&gt;阻塞队列（Blocking Queue）是一个支持两个附加操作的队列。这两个
      
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="队列" scheme="http://yoursite.com/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="阻塞队列" scheme="http://yoursite.com/tags/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
      <category term="BlockingQueue" scheme="http://yoursite.com/tags/BlockingQueue/"/>
    
  </entry>
  
  <entry>
    <title>阿里养猪</title>
    <link href="http://yoursite.com/2019/04/12/%E9%98%BF%E9%87%8C%E5%85%BB%E7%8C%AA/"/>
    <id>http://yoursite.com/2019/04/12/阿里养猪/</id>
    <published>2019-04-12T14:23:00.000Z</published>
    <updated>2019-04-12T14:23:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阿里养猪"><a href="#阿里养猪" class="headerlink" title="阿里养猪"></a>阿里养猪</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>小明是一个数学家，他喜欢用数字给事物命名编号，他给自己编号为1，同时在2019年小明开办了一个农场，准备开始养母猪，他专门给农场的母猪用以下数列2，3，4，5，7，9，12，16，21，28，37，49，65，86，114，151…进行命名。假设农场的母猪永远不会死，小母猪出生后3年后成熟，成熟后从第三年开始每年只会生一只小母猪。第一年农场，有一只刚刚出生的小母猪和一只成熟的母猪(本年不再生小猪，下一年开始生小猪)，并给他们编号为2和3。请问，第m只母猪编号为多少？其是哪一年出生的？小明还准备了1份礼物，专门颁给农场第1到m只的母猪颁奖，颁奖规则如下:选出第1到m只的母猪翻转编号(114编号翻转为411)为第k大的母猪进行颁奖，请问是第几只猪获奖？提示: f(n)=f(n-2)+f(n-3)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">输入两个参数半角逗号分隔</span><br><span class="line">m,k</span><br><span class="line">输出:</span><br><span class="line">输出三个数字半角逗号分隔</span><br><span class="line">第m只母猪编号,哪一年出生,第几只小猪获奖</span><br><span class="line">输入范例:</span><br><span class="line">20,3</span><br><span class="line">输出范例:</span><br><span class="line">465,2024,15</span><br></pre></td></tr></table></figure><p>我的答案。没测过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YangPig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Pair</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Pair o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o.value - <span class="keyword">this</span>.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">        array[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">        array[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">        array[<span class="number">2</span>] = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; m; i++) &#123;</span><br><span class="line">            array[i] = array[i - <span class="number">2</span>] + array[i - <span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        res += array[m - <span class="number">1</span>] + <span class="string">"."</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> year = <span class="number">2020</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &gt;= m) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp = b;</span><br><span class="line">            b = a + b;</span><br><span class="line">            a = tmp;</span><br><span class="line">            year++;</span><br><span class="line">        &#125;</span><br><span class="line">        res += year + <span class="string">"."</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            array[i] = reverse(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Pair[] pairs = <span class="keyword">new</span> Pair[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            pairs[i] = <span class="keyword">new</span> Pair();</span><br><span class="line">            pairs[i].index = i;</span><br><span class="line">            pairs[i].value = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(pairs);</span><br><span class="line">        res += ++pairs[k - <span class="number">1</span>].index;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            res *= <span class="number">10</span>;</span><br><span class="line">            res += n % <span class="number">10</span>;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(calculate(<span class="number">20</span>, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>第一个问题：求序号，不用说，比较好求。</p><p>第二个问题：求第m个猪是第几年出生的。题目中成熟后从第三年开始每年只会生一只小母猪。这个问题和斐波那契的那个问题很像，斐波那契问题中是兔子三个月后就成熟了，可以生兔子了，而这里的是猪。第一年2，第二年3个，第三年5个，递推公式是f(n) = f(n - 1) + f(n - 2)。</p><p>第三个问题：求编号反转后的第k大的，先反转，这个也很简单。但是这里有一个问题是第k大的猪，首先能想到的是排序，但是排序后有一个问题就是反转后的编号在数组中的位置变了，而题目的要求是反转后编号第k大猪，所以这里的需要记录在数组中出现的序号。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;阿里养猪&quot;&gt;&lt;a href=&quot;#阿里养猪&quot; class=&quot;headerlink&quot; title=&quot;阿里养猪&quot;&gt;&lt;/a&gt;阿里养猪&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h
      
    
    </summary>
    
      <category term="笔试" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AF%95/"/>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AF%95/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="养猪" scheme="http://yoursite.com/tags/%E5%85%BB%E7%8C%AA/"/>
    
      <category term="阿里笔试" scheme="http://yoursite.com/tags/%E9%98%BF%E9%87%8C%E7%AC%94%E8%AF%95/"/>
    
      <category term="斐波那契" scheme="http://yoursite.com/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"/>
    
  </entry>
  
  <entry>
    <title>AQS源码分析</title>
    <link href="http://yoursite.com/2019/04/11/AQS%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/04/11/AQS分析/</id>
    <published>2019-04-11T14:21:45.000Z</published>
    <updated>2019-04-11T14:21:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AQS源码分析"><a href="#AQS源码分析" class="headerlink" title="AQS源码分析"></a>AQS源码分析</h1><p>Java并发包的Lock接口的实现基本上都是通过聚合一个同步容器的子类来完成线程控制访问的。</p><h2 id="队列同步容器-：-AbstractQueuedSynchronizer"><a href="#队列同步容器-：-AbstractQueuedSynchronizer" class="headerlink" title="队列同步容器 ： AbstractQueuedSynchronizer"></a>队列同步容器 ： AbstractQueuedSynchronizer</h2><p>队列同步容器（AbstractQueuedSynchronizer），使用来构建其他同步组件的基本框架，它使用了一个int型的成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><p>同步容器的主要的工作方式是继承，子类通过继承同步容器并实现它的抽象方法来同步管理状态，在抽象方法实现的过程中避免不了对同步状态的更改，这时就需要使用同步器提供的三个方法（getState()、setState(int newState)和compareAndSetState(int exect, int update)）来进行操作，因为它们是能够保证状态的改变是安全的。子类被推荐定义为自定义同步组件的静态内部类，同步器本身没有实现任何的同步接口，它仅仅定义了若干同步状态的获取和释放方法来供自定义同步组件使用，同步器可以独占的获取同步状态，也可以共享的获取同步状态，这样就方便实现不同类型的同步组件(ReentrantLock、ReentrantReadWriteLock和CountDownLatch等)。</p><p>AQS定义资源共享的方式：</p><ol><li>Exclusive 独占，只有一个线程能执行。</li><li>Share 共享，多个线程可以同事执行，如Semaphore和CountDownLatch</li></ol><p>同步器是实现锁和其他任意同步组件的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。</p><h3 id="对列同步器的接口与示例"><a href="#对列同步器的接口与示例" class="headerlink" title="对列同步器的接口与示例"></a>对列同步器的接口与示例</h3><p>同步器的设计是基于模板方法的，也就是说，使用者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用着重写的方法。</p><p>重写同步器指定的方法时，需要使用同步器提供的如下3个方法来访问或修改同步状态。</p><ul><li>getState(): 获取当前同步状态。</li><li>getState(int newState):设置当前同步状态。</li><li>compareAndSetState(int expect, int update)：使用CAS设置当前状态，该方法能够保证设置状态的原子性。</li></ul><p>同步器可以重写的方法如下：</p><table><thead><tr><th style="text-align:left">方法名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">protected boolean tryAcquire(int arg)</td><td style="text-align:left">独占式获取同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期。然后在进行CAS设置同步状态</td></tr><tr><td style="text-align:left">protected boolean tryRelease(int arg)</td><td style="text-align:left">独占方式释放同步状态，等待获取同步的线程将有机会获取同步状态</td></tr><tr><td style="text-align:left">protected int tryAcquireShared(int arg)</td><td style="text-align:left"><strong>共享获取同步状态</strong>，返回值大于等于0的值，表示获取成功，反之获取失败</td></tr><tr><td style="text-align:left">protected boolean tryReleaseShared(int arg)</td><td style="text-align:left">共享释放同步状态</td></tr><tr><td style="text-align:left">protected boolean isHeldExeclusively()</td><td style="text-align:left">当前线程是否在独占模式下被线程占用，一般该方法表示是否被当前线程所占用</td></tr></tbody></table><p>实现自定义同步组件时，会调用同步器提供的模板方法，这些模板方法如下：<br>|方法名称|描述|<br>|:—|:—|<br>|void acquire|独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步对列等待，该方法将会调用重写的tryAcquire(int arg)方法|<br>|void acquireInterruptibly(int arg)|与acquire(int arg)方法相同，但是个该方法可以响应中断，当前线程为获取同步状态而进入同步对列中，如果当前线程被中断，该方法会抛出InterruptedException并返回|<br>|boolean tryAcquireNanos(int arg, long nanos)|在acquireInterruptibly(int arg)基础上增加了超时限制当前线程在规定的时间内没有获取同步状态，那么将返回false，如果获取到了返回true|<br>|void acquireShared(int arg)|共享的方式获取同步状态，如果当前线程未获取到同步状态，将会进入同步对列等待，与独占的方式获取的主要区别是在同一时刻可以有多个线程获取到同步状态|<br>|void acquireSharedInterruptibly(int arg, long nanos)|与acquireShared()方法相同，该方法响应中断|<br>|boolean tryAcquireSharedNanos(int arg, int nanos)|在acquireSharedInterruptibly(int arg)基础上增加了超时限制|<br>|boolean release(int arg)|独占的方式释放同步状态，该方法会在释放同步状态之后，将同步状态的第一个节点包含的线程唤醒|<br>|boolean releaseShared(int arg)|共享的方式释放同步状态|<br>|Collection<thread> getQueuedThreads()|获取等待在同步队列上的线程集合|<br>同步器上提供的模板方法基本上有三类：</thread></p><ul><li>独占的方式获取与释放同步状态;</li><li>共享的方式获取与方式同步状态;</li><li>查询同步队列中的线程等待情况。</li></ul><p>以ReentrantLock为例,state初始化为0，表示为锁定状态，A线程lock()时，会调用<code>tryAcquire()</code>独占该锁并将state+1。此后，其它线程再tryAcquire()是就会失败，直到A线程unLock()，state=0(即释放锁)，其它线程才有机会获取该锁，当然，释放锁之前，A线程自己是可以重复获取此锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这也就是可重入。</p><h3 id="队列同步器的实现分析"><a href="#队列同步器的实现分析" class="headerlink" title="队列同步器的实现分析"></a>队列同步器的实现分析</h3><h4 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h4><p>同步器依赖与一个队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态的信息构造成一个节点(Node)并将其加入同步队列，同时会吧当前线程阻塞，当同步状态释放时，会把首节点中的线程唤醒，使其再次获取同步状态。<br><img src="http://img-blog.csdnimg.cn/20190411220916754.png" alt="同步队列">)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">     * unconditionally propagate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    Node nextWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的是节点的属性与名称及描述</p><ul><li><code>int waitStatus</code>等待的状态，包含如下：<ol><li>CANCELLED，值为1，由于同步队列中的等待的线程等待超时或者被中断，需要中同步队列中取消等待，节点进入该状态将不会变化。</li><li>SIGNAL，值为-1，后继节点的线程处于等待状态，当前节点如果释放了同步状态或者被取消，将会通知该节点，使得后继节点得以运行。</li><li>CONDITION，值为-2，节点在等待队列中，节点线程等待在Condition上，当其它线程对Condition调用了signal()方法后，该节点将会从等待队列中转移到同步队列中，加入到对同步状态的获取中。</li><li>PROPAGATE，值为-3，状态需要向后传播，表示releaseShared需要被传播给后续节点，仅在共享锁模式下使用。</li><li>INITIAL，值为0，初始状态。</li></ol></li><li><code>Node prev</code>: 前驱节点，当节点加入同步队列时被设置（尾部添加）</li><li><code>Node next</code>: 后继节点。</li><li><code>Node nextWaiter</code>:等待队列中的后继节点。如果当前节点是共享的，那么这个字段将是一个SHARED常量，也就是说节点类型（独占和共享）和等待队列中的后继节点公用一个字段。</li><li><code>Thread thread</code>：获取同步状态的线程。</li></ul><p>Node是过程同步队列的基础，同步器拥有head和tail，获取同步状态失败的线程将会成为节点加入该队列的尾部。这里加入队列的过程必须要保证线程安全，因此同步器是一个基于CAS的设置节点的方法：compareAndSendTail(Node expect, Node update)，它需要传递当前线程“认为”的尾节点，只有设置成功，当前节点才正式与尾节点建立关联。</p><p>同步队列遵循FIFO，首节点是获取同步状态成功的节点，首节点在释放同步状态时，会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功的获取到同步状态，因此设置头结点的方法并不需要使用CAS来保证，它只需要将首节点设置成原首节点的后继节点并断开首节点与next引用即可。</p><h4 id="2-独占式同步状态获取和释放"><a href="#2-独占式同步状态获取和释放" class="headerlink" title="2. 独占式同步状态获取和释放"></a>2. 独占式同步状态获取和释放</h4><p>通过AQS的acquire(int arg)方法可以获取同步状态，该方法不响应中断，也就是说，由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，线程不会从同步队列中移出。</p><p>这个方法是线程来获取共享资源的入口，如果获取到资源，方法直接返回，来来来否则进入等待队列，直到获取到资源为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码主要完成了同步状态获取、节点构造、加入同步队列以及同步队列中自旋等待的相关工作，其流程如下：</p><ol><li><p>通过<code>tryAcquire()</code>方法尝试获取锁，这个方法需要实现类自己实现获取锁的逻辑，获取锁成功后则不执行后面的加入等待队列的逻辑。 </p></li><li><p>如果尝试获取锁失败后，调用<code>addWaiter()</code> 方法将当前线程封装成一个Node对象，并加入队列的尾部。其中：</p><ul><li>Node.EXCLUSIVE 表示独占是获取同步状态。</li><li>Node.SHARED 表示共享式获取同步状态</li></ul></li><li><code>acquireQueued()</code> 调用这个方法使的该节点以“死循环”的方式获取同步状态，如果获取不到则阻塞节点中的线程，而被阻塞的线程的唤醒主要依靠前去节点出队或阻塞线程被中断来实现。</li></ol><h5 id="1-tryAcquire-int-arg-方法"><a href="#1-tryAcquire-int-arg-方法" class="headerlink" title="1. tryAcquire(int arg)方法"></a>1. tryAcquire(int arg)方法</h5><p>这个方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如前面提到的这是一个需要子类实现的方法。这个方法的方法体内只是抛出了一个异常，一般当不支持请求操作时，抛出该异常。</p><h5 id="2-addWaiter-Node-mode-方法"><a href="#2-addWaiter-Node-mode-方法" class="headerlink" title="2. addWaiter(Node mode)方法"></a>2. addWaiter(Node mode)方法</h5><p>此方法的作用是将当前的线程构造成一个节点，然后添加进队列中，并返回当前线程所在节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Node有两种模式</span></span><br><span class="line"><span class="comment">     * - EXCLUSIVE 独占</span></span><br><span class="line"><span class="comment">     * - SHARED 共享</span></span><br><span class="line"><span class="comment">     * 创建一个基于当前线程的节点，该节点是Node.EXCLUSIVE</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="comment">// 快速尝试</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 这里判断队尾是不是为空，如果不为空则直接将节点加入队尾</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 采取CAS操作，将当前节点设置为队尾节点，由于采用了CAS原子操作，无论怎么修改，都有且只有一条线程可以修改成功，其余都将执行后面的enq方法</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果失败则通过enq入队</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单来说<code>addWaiter(Node mode)</code>方法做了两件事情：</p><ol><li>创建基于当前线程的独占类型的节点。</li><li>将节点加入队尾。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// CAS"自旋"，直到成功入队</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">// 队列为空，创建一个空的标志节点作为head节点，并将tail也指向它</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 正常入队</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个CAS自旋的用法。如果<code>compareAndSetHead</code>或<code>compareAndSetTail()</code>返回false，那么就说明有其他线程修改了head或tail，然后进入下一个循环继续。</p><h5 id="3-acquireQueued-final-Node-node-int-arg-方法"><a href="#3-acquireQueued-final-Node-node-int-arg-方法" class="headerlink" title="3. acquireQueued(final Node node, int arg)方法"></a>3. acquireQueued(final Node node, int arg)方法</h5><p>获取资源失败后，获取资源的线程被添加进入队列后，下一步的做法就是进入等待状态，直到其它线程彻底释放资源后唤醒自己。</p><p>这里需要说明一点的是，head节点代表当前持有锁的线程，那么如果当前节点的pred节点是head节点，很可能此时head节点已经释放锁了，所以此时需要再次尝试获取锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个变量使用来标记是否成功获取到资源，也就是是否成功获取到锁</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 标记等待过程中是否可以被中断</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 下面的是一个CAS自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果p是队列的首节点并且能够获取到资源</span></span><br><span class="line">            <span class="comment">// 如果当前节点的前驱节点是头节点，那么当前节点（线程）就有机会获取锁了</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 拿到资源（获取到锁）后，将当前节点设置为首节点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">// 然后将前驱节点的next设置为空，有助于垃圾回收器回收</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="comment">// 成功获取</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">// 等待的过程被中断了</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检查是否可以等待</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 如果等待过程中被中断过，那么就将interrupted标记为true</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步<code>acquireQueued(final Node node, int arg)</code>方法主要做了以下事情：</p><ol><li>判断当前节点的前驱节点pred是否是head节点，如果是，尝试获取锁；</li><li>获取失败后，进入挂起逻辑。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Node类中的一个方法，获取当前节点的前驱节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">    Node p = prev;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置首节点为node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个方法主要是检查状态，查看是否可以等待</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拿到前驱节点的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 如果前驱节点的状态为SIGNAL，那么就可以进行等待，因为当前驱节点的waitStatus是Node.SIGNAL，那么释放同步锁的时候，会唤醒后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果前驱节点放弃了对锁的持有(放弃获取同步状态了)，那么就一直往前找，直到找到一个没有放弃获取同步状态的节点，然后插在它的后面</span></span><br><span class="line"><span class="comment">         * 也就是说当当前节点的前驱节点是CANCELLED，需要从队列中删除</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// pred = pred.prev</span></span><br><span class="line">            <span class="comment">// node.prev = pred</span></span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果前驱节点是其他状态，那么就把前驱节点的状态设置成SIGNAL，然后进可以进行等待了</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步<code>houldParkAfterFailedAcquire(Node pred, Node node)</code>方法主要做了以下事情：</p><ol><li>判断pred节点状态，如果尾SIGNAL，则返回true执行挂起。</li><li>删除状态为CANCELLED的节点。</li></ol><p>下面的是acquire(int arg)方法的大致流程：<br><img src="http://img-blog.csdnimg.cn/20190411220916754.png" alt="AQS的acquire方法"></p><h5 id="独占式释放资源"><a href="#独占式释放资源" class="headerlink" title="独占式释放资源"></a>独占式释放资源</h5><p>在获取同步状态并执行响应的逻辑后，就需要释放同步状态，使得后续的节点能够继续获取同步状态。通过调用同步器的release(int arg)方法可以释放同步状态，该方法在释放同步状态后，会唤醒其后继节点，进而使后继节点获取同步状态。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 和tryAcquire()方法一样都是需要子类实现的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// node一般为当前线程所在的节点</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// 将当前的线程状态设置为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 找到下一个节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 如果为空或者已经取消</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        从尾部遍历到当前节点，找到最后一个waitStatus &lt;= <span class="number">0</span>的</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 然后唤醒</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法执行时候时，会唤醒后继节点，<code>unparkSuccessor(Node node)</code>方法使用LockSupport来唤醒处于等待状态的线程。中间的过程是寻找一个waitStatus &lt;= 0的节点，当waitStatus &lt;= 0时也就意味着这个节点没有放弃获取同步状态。</p><h4 id="3-共享式获取同步状态和释放"><a href="#3-共享式获取同步状态和释放" class="headerlink" title="3. 共享式获取同步状态和释放"></a>3. 共享式获取同步状态和释放</h4><h5 id="共享式获取资源"><a href="#共享式获取资源" class="headerlink" title="共享式获取资源"></a>共享式获取资源</h5><p>共享式和独占式获取最重要的区别是<strong>同一个时刻能否有多个线程同时获取到同步状态</strong>。例如读写锁，可以有多个线程获取读的状态，但是只能有一个线程获取写的状态。读写锁就用到了这里的“共享式”。</p><p>通过调用同步器的acquireShared(int arg)方法可以共享的获取同步状态，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面说过<code>tryAcquireShared()</code>这个方法需要子类取实现。如果这个方法返回值小于0代表获取失败，0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以获取。如果获取成功直接返回，如果获取失败则进入<code>doAcquireShared(int arg)</code>，将获取同步状态失败的线程放在同步队列中。<br>下面是<code>doAcquireShared(int arg)</code>的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将当前线程通过共享式构造出一个节点（Node）并加入队列尾部</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="comment">// 这是一个是否失败的标志</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 线程是否被中断</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 获取前驱节点是head，这里很有可能是head用完资源后然后将node唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 再次尝试获取资源</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 将head指向自己。还有剩余资源时唤醒其他线程</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="comment">// 如果等待过程中被中断，此时将node中的线程中断</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断自己能否进入等待状态</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个和独占式获取很像，不过是将<code>selfInterrupt()</code>放在了上面的这个方法里。这里值得注意的是<strong>资源的数量</strong>，不独占式获取资源不同的是，独占式永远只有一个线程获取到同步状态，而共享式可以有多个线程获取同步状态，而且有的线程可能在有多个资源时才能获取到。所以这里就有了一个<code>setHeadAndPropagate(Node, int)</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * node指的是当前线程构成的节点</span></span><br><span class="line"><span class="comment"> * propagate 是指剩余的资源数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录当前头节点</span></span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    <span class="comment">// 设置新的头节点，即把当前获取到锁的节点设置为头节点</span></span><br><span class="line">    <span class="comment">// 注意：这里是获取到锁之后的操作，不需要并发控制</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">// 注意这里有两种情况是需要执行唤醒操作的</span></span><br><span class="line">    <span class="comment">// 1. propagate &gt; 0 表示调用方指明了后继节点需要被唤醒</span></span><br><span class="line">    <span class="comment">// 2. 头节点后面的节点需要被唤醒（waitStatus），无论是老的头节点还是新的头节点</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">// 如果当前节点没有后继节点是共享类型或者没有后继节点，则进行唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在个方法比前面的setHead()方法多了一点就是如果有资源剩余那么就去唤醒下一个的共享线程。其中的doReleaseShared()是释放共享资源的方法，这个会在下面的释放共享资源中说到。</p><h5 id="共享式释放资源"><a href="#共享式释放资源" class="headerlink" title="共享式释放资源"></a>共享式释放资源</h5><p>共享式释放资源使用的是<code>releaseShared(int arg)</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 这个方法中会唤醒后继的节点</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>和独占式释放资源一样，其中的<code>tryReleaseShared(arg)</code>需要子类去实现，如果释放成功会返回true，下面会执行<code>doReleaseShared()</code>方法，这个方法中会尝试唤醒后继节点中的线程，它的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 唤醒操作由头节点开始，注意这里的头节点已经是上面重新设置的头节点</span></span><br><span class="line">        <span class="comment">// 这里其实是唤醒共享锁节点的后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// 表示后继需要被唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// CAS 比较失败说明线程已经被唤醒了</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 如果CAS比较成功，则使用LockSupport唤醒线程</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果后继节点暂时不需要唤醒，则把当前节点的状态设置为PROPAGATE，确保可以传递下去</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// head被改变</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AQS源码分析&quot;&gt;&lt;a href=&quot;#AQS源码分析&quot; class=&quot;headerlink&quot; title=&quot;AQS源码分析&quot;&gt;&lt;/a&gt;AQS源码分析&lt;/h1&gt;&lt;p&gt;Java并发包的Lock接口的实现基本上都是通过聚合一个同步容器的子类来完成线程控制访问的。&lt;/p&gt;
      
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="异步" scheme="http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
      <category term="JUC" scheme="http://yoursite.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Callable和Future详解</title>
    <link href="http://yoursite.com/2019/04/09/Callable%E5%92%8CFuture%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/04/09/Callable和Future详解/</id>
    <published>2019-04-09T08:39:45.000Z</published>
    <updated>2019-04-11T14:05:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Callable和FutureTask详解"><a href="#Callable和FutureTask详解" class="headerlink" title="Callable和FutureTask详解"></a>Callable和FutureTask详解</h1><p>一般来说，要进行异步计算的时候可以使用Callable和Future或者FutureTask进行。下面我们来探究一下Callable和FutureTask。</p><h2 id="Callable和Future"><a href="#Callable和Future" class="headerlink" title="Callable和Future"></a>Callable和Future</h2><p>Callable是一个接口，它的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Callable和Runnable之间的区别是：Callable有返回值，并且可以抛出异常，而Runnable不可以。</p><p><strong>Callable一般需要和FutureTask或者线程池结合使用</strong>。</p><p>下面我们来看一下Future接口的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消正在运行的任务</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否取消了</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否结束了</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结果，如果任务还没有执行结束，那么就阻塞</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限时等待，如果超时就抛出异常</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面通过两个Demo来演示下FutureTask和线程池与Callable结合使用。</p><h2 id="Callable和两个Demo"><a href="#Callable和两个Demo" class="headerlink" title="Callable和两个Demo"></a>Callable和两个Demo</h2><p>第一个Demo是和线程池结合使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            log.info(<span class="string">"do something in callable"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Done"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(<span class="keyword">new</span> MyCallable());</span><br><span class="line">        log.info(<span class="string">"do something in main"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        log.info(<span class="string">"result: "</span> + future.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个Demo是和FutureTask结合着使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">"do something in callable"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Done"</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        log.info(<span class="string">"do something in main"</span>);</span><br><span class="line">        String result = futureTask.get();</span><br><span class="line">        log.info(<span class="string">"result: &#123;&#125;"</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，线程池中使用的也是FutureTask来结合Callable使用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的RunnableFuture是一个接口，它即继承了Runnable也继承了Future，它的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RunnableFuture</code>中使用了适配器模式，这里的<code>RunnableFuture</code>既可以是Runnable及它的实现类，也可以是Future及它的实现类，在Runnable和Future之间做了适配。</p><p>下面来看一下FutureTask中如何实现的Callable异步任务。</p><h2 id="FutureTask原理探究"><a href="#FutureTask原理探究" class="headerlink" title="FutureTask原理探究"></a>FutureTask原理探究</h2><p>FutureTask 封装了一个Callable。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br></pre></td></tr></table></figure><p>FutureTask中定义了Callable的运行中的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="comment">// FutureTask的几种状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>这几种的关系转换如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NEW -&gt; COMPLETING -&gt; NORMAL             // 没有发生异常，也没有被canceled</span><br><span class="line">NEW -&gt; COMPLETING -&gt; EXCEPTIONAL        // 执行过程中发生异常</span><br><span class="line">NEW -&gt; CANCELLED                        // 执行后被取消</span><br><span class="line">NEW -&gt; INTERRUPTING -&gt; INTERRUPTED      // INTERRUPTED被中断</span><br></pre></td></tr></table></figure><p>FutureTask中封装的返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The result to return or exception to throw from get() */</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/</span></span><br></pre></td></tr></table></figure><p>FutureTask中使用了一个volatile的变量表示callable的运行状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The thread running the callable; CASed during run() */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br></pre></td></tr></table></figure><p>当有一个线程请求FutureTask最后的返回结果，但是FutureTask中的任务没有完成，那么会把它加入同步等待队列中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Treiber stack of waiting threads */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line">    WaitNode() &#123; thread = Thread.currentThread(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们来看看FutureTask的构造器：</p><ol><li><p>通过Callable创建一个FutureTask，源码如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过Runnable和一个result创建一个FutureTask：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><pre><code>这里通过`Executors`工具类创建了一个Callable。</code></pre><p>下面我们来看看FutureTask的核心源码它的run()方法，它的run()方法，也就是一个Thread类start()之后的会执行的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果state不是NEW状态，那么尝试使用CAS把Runner设置为当前线程，如果设置成功，继续执行，如果设置失败，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !RUNNER.compareAndSet(<span class="keyword">this</span>, <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="comment">// 再次判断</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用call</span></span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行结束，设置结果</span></span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">// 重读state，放置中断泄露</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是catch块中的语句，如果正在运行的线程调用了cancel(true)方法来中断正在执行任务的线程，<strong>除非在Callable的call()方法实现上设计成响应中断，否则是不会中断callable.call()方法的执行的</strong>。</p><p>下面看看上面的方法中调用的几个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置为完成状态</span></span><br><span class="line">    <span class="keyword">if</span> (STATE.compareAndSet(<span class="keyword">this</span>, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = t;</span><br><span class="line">        <span class="comment">// 然后设置为EXCEPTIONAL状态</span></span><br><span class="line">        STATE.setRelease(<span class="keyword">this</span>, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">        <span class="comment">// 唤醒正在等待的线程</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (STATE.compareAndSet(<span class="keyword">this</span>, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        <span class="comment">// 这里设置称为正常退出的状态</span></span><br><span class="line">        STATE.setRelease(<span class="keyword">this</span>, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="comment">// 这里通过CAS和LockSupport进行逐个唤醒</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (WAITERS.weakCompareAndSet(<span class="keyword">this</span>, q, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    done();</span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来看看FutureTask的get()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="comment">// 没有完成，则等待完成</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// The code below is very delicate, to achieve these goals:</span></span><br><span class="line">    <span class="comment">// - call nanoTime exactly once for each call to park</span></span><br><span class="line">    <span class="comment">// - if nanos &lt;= 0L, return promptly without allocation or nanoTime</span></span><br><span class="line">    <span class="comment">// - if nanos == Long.MIN_VALUE, don't underflow</span></span><br><span class="line">    <span class="comment">// - if nanos == Long.MAX_VALUE, and nanoTime is non-monotonic</span></span><br><span class="line">    <span class="comment">//   and we suffer a spurious wakeup, we will do no worse than</span></span><br><span class="line">    <span class="comment">//   to park-spin for a while</span></span><br><span class="line">    <span class="keyword">long</span> startTime = <span class="number">0L</span>;    <span class="comment">// Special value 0L means not yet parked</span></span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="comment">// 如果任务完成了，则返回</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                q.thread = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果s == COMPLETING，则说明任务已经完成了</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING)</span><br><span class="line">            <span class="comment">// We may have already promised (via isDone) that we are done</span></span><br><span class="line">            <span class="comment">// so never return empty-handed or throw InterruptedException</span></span><br><span class="line">            <span class="comment">// 然后进行让步，让这行任务的线程继续执行，因为就差设置outcome的值了</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">// 如果线程被中断了，则抛出线程，这里是为了影响中断</span></span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果队列为空，则直接等待，如果这里timed为false，也就是不需要等待，那么把用当前线程构造一个等待队列的头结点</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            <span class="comment">// 把当前等待线程加入等待队列中</span></span><br><span class="line">            queued = WAITERS.weakCompareAndSet(<span class="keyword">this</span>, q.next = waiters, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> parkNanos;</span><br><span class="line">            <span class="keyword">if</span> (startTime == <span class="number">0L</span>) &#123; <span class="comment">// first time</span></span><br><span class="line">                startTime = System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (startTime == <span class="number">0L</span>)</span><br><span class="line">                    startTime = <span class="number">1L</span>;</span><br><span class="line">                <span class="comment">// 等待时间</span></span><br><span class="line">                parkNanos = nanos;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// elapsed 已经等待的时间</span></span><br><span class="line">                <span class="keyword">long</span> elapsed = System.nanoTime() - startTime;</span><br><span class="line">                <span class="comment">// 已经等待的时间大于等待时间</span></span><br><span class="line">                <span class="keyword">if</span> (elapsed &gt;= nanos) &#123;</span><br><span class="line">                    删除这个节点</span><br><span class="line">                    removeWaiter(q);</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">                parkNanos = nanos - elapsed;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// nanoTime may be slow; recheck before parking</span></span><br><span class="line">            <span class="comment">// 阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (state &lt; COMPLETING)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, parkNanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Callable和FutureTask详解&quot;&gt;&lt;a href=&quot;#Callable和FutureTask详解&quot; class=&quot;headerlink&quot; title=&quot;Callable和FutureTask详解&quot;&gt;&lt;/a&gt;Callable和FutureTask详解&lt;/
      
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="异步" scheme="http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java读写锁</title>
    <link href="http://yoursite.com/2019/04/08/Java%E8%AF%BB%E5%86%99%E9%94%81/"/>
    <id>http://yoursite.com/2019/04/08/Java读写锁/</id>
    <published>2019-04-08T10:50:00.000Z</published>
    <updated>2019-04-09T00:37:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ReentrantReadWriteLock-分析"><a href="#ReentrantReadWriteLock-分析" class="headerlink" title="ReentrantReadWriteLock 分析"></a>ReentrantReadWriteLock 分析</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>ReentrantReadWriteLock是读写锁，我们一般所说的锁都是排他锁，这些锁在同意时刻只允许一个线程进行访问，而<strong>读写锁在同一时刻可以允许多个线程同时访问，但是在写线程访问的时，所有的读线程和其他的写线程均被阻塞。</strong> <strong>读写锁维护了一对锁，一个读锁和一个写锁</strong>，通过分离读锁和写锁，使得并发相比一般的排他锁有了很大的提升。</p><p>除了保证写操作对读操作的可见性以及并发性的提升之外，读写锁能过简化读写交互场景的编程方式。</p><p>下面来看ReentrantReadWriteLock的特性</p><table><thead><tr><th style="text-align:center">特性</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">公平性选择</td><td>支持非公平（默认）和公平锁获取方式，吞吐量还是非公平优于公平</td></tr><tr><td style="text-align:center">重进入</td><td>该锁支持重进入，以读写线程为例：读线程获取锁之后，能够再次获取读锁。而写线程在获取写锁之后能够再次获取写锁，同时也可以获取读锁</td></tr><tr><td style="text-align:center">锁降级</td><td>遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级称为读锁</td></tr></tbody></table><h2 id="2-读写锁的使用"><a href="#2-读写锁的使用" class="headerlink" title="2. 读写锁的使用"></a>2. 读写锁的使用</h2><p>ReadWriteLock仅定义了获取读锁和写锁的两个方法。即readLock()方法和writeLock()方法，而其实现——ReentrantReadWriteLock，除了接口方法之外，还提供了便于外界监控其内部工作状态的方法，这些方法描述如下表：</p><table><thead><tr><th>方法名称</th><th>描述</th></tr></thead><tbody><tr><td>int getReadLockCount()</td><td>返回当前锁被获取的次数。该次数不等于获取锁的读线程数，例如，仅一个线程，它连续获取了n次读锁，那么占据读锁的线程数是1，但该方法返回n</td></tr><tr><td>int getReadHoldCount()</td><td>返回当前线程获取读锁的次数。该方法在Java6中加入到ReentrantReadWriteLock中，使用ThreadLocal保存当前线程获取的次数</td></tr><tr><td>boolean isWriteLocked()</td><td>判断写锁是否被获取</td></tr><tr><td>int getWriteHoldCount()</td><td>返回当前写锁被获取的次数</td></tr></tbody></table><p>接下来，通过一个缓存的实例说明读写锁的使用方式，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="keyword">static</span> Lock r = rwl.readLock();</span><br><span class="line">    <span class="keyword">static</span> Lock w = rwl.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个key对应的value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置一个key对应的value，并返回就的value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> map.put(key, value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空所有的内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            map.clear();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例中，Cache组合一个非线程安全的HashMap作为缓存的实现，同时使用读写锁的读锁和写锁来保证Cache是线程安全的。在读操作<code>get(String key)</code>方法中，需要获取读锁，这使得并发访问不会被阻塞。写操作<code>put(String key, Object value)</code>方法和<code>clear()</code>方法，在更新HashMap时必须提前获取写锁，当获取写锁后，其他线程对于读锁和写锁的获取均被阻塞，而只有写锁释放之后，其他读锁操作才能继续。Cache使用读写锁提升读操作的并发性，也保证每次读操作对所有写操作的可见性，同时简化了编程。</p><h2 id="3-实现原理分析"><a href="#3-实现原理分析" class="headerlink" title="3. 实现原理分析"></a>3. 实现原理分析</h2><p>读写锁的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for reading.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for reading</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for writing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for writing</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReadWriteLock仅有两个方法：</p><ol><li><code>readLock()</code>: 获取读锁。</li><li><code>writeLock()</code>: 获取写锁。</li></ol><h3 id="1-读写锁的状态设计"><a href="#1-读写锁的状态设计" class="headerlink" title="1. 读写锁的状态设计"></a>1. 读写锁的状态设计</h3><p>读写锁同样依赖自定义同步器实现同步功能，而读写状态就是其同步器的状态。读写锁的自定义的同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态，使得该状态的设计成为读写锁实现的关键。</p><p>如果在一个整型变量上维护多种状态，就一定需要“<strong>按位切割使用</strong>”这个变量，读写锁将变量切割成两部分，高16位表示读，低16位表示写，划分方式如图：</p><p><img src="https://img-blog.csdn.net/20170521115701777?" alt="读写锁的状态"></p><p>当前同步状态表示一个线程已经获取了写锁，且重进入了两次，同时也连续获取了两次读锁读锁。读写锁是如何迅速确定读和写各自的状态呢？答案是通过位运算。假设当前同步状态值为S，写状态等于S&amp;0x0000FFFF(将高16为全部去掉)，读状态等于S&gt;&gt;&gt;16(无符号补0右移16位)。当写状态增加1时，等于S+1，当读状态增加1时，等于S + (1 &lt;&lt; 16)，也就是S + 0x000010000。</p><p>根据状态能得出一个推论：S不等于0时，当写状态（S &amp; 0x0000FFFF）等于0，则读状态（S &gt;&gt;&gt; 16）大于0，即读锁已被获取。</p><h3 id="2-写锁的获取与释放"><a href="#2-写锁的获取与释放" class="headerlink" title="2. 写锁的获取与释放"></a>2. 写锁的获取与释放</h3><p>写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写锁的状态。如果当前线程在获取写锁时，读锁已被获取（读锁的状态不为0）或着该线程不是已经获取写锁的线程，当前线程进入等待状态，获取写锁的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Walkthrough:</span></span><br><span class="line"><span class="comment">     * 1. If read count nonzero or write count nonzero</span></span><br><span class="line"><span class="comment">     *    and owner is a different thread, fail.</span></span><br><span class="line"><span class="comment">     * 2. If count would saturate, fail. (This can only</span></span><br><span class="line"><span class="comment">     *    happen if count is already nonzero.)</span></span><br><span class="line"><span class="comment">     * 3. Otherwise, this thread is eligible for lock if</span></span><br><span class="line"><span class="comment">     *    it is either a reentrant acquire or</span></span><br><span class="line"><span class="comment">     *    queue policy allows it. If so, update state</span></span><br><span class="line"><span class="comment">     *    and set owner.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// current表示当前线程</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// c表示读写锁的状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// w表示获取写锁的次数, exclusiveCount(int c)返回的是获取写锁的次数</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="comment">// c != 0 表示有线程获取了读锁或者写锁</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">        <span class="comment">// 如果读写锁的状态不为0，并且写锁的状态为0，那么肯定读锁的状态不为0</span></span><br><span class="line">        <span class="comment">// 存在读锁或者当前线程不是已经获取锁的线程</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// Reentrant acquire</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// writerShouldBlock() 这里如果是非公平锁直接返回false，如果是公平锁的话，判断前面是否有节点，如果有返回true，如果没有返回flase</span></span><br><span class="line">    <span class="comment">// writerShouldBlock() 返回true，表示前面有头结点，然后cas尝试获取锁，如果获取成功，则可以进行下面的操作，如果失败，则返回flase。</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 设置当前线程为持有锁的线程</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法除了重入条件（当前线程为获取了写锁的线程）之外，增加了一个读锁是否存在的判断。如果读锁存在，则写锁不能被获取，原因在于：读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读线程的后续访问均被阻塞。</p><p>写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0时表示写锁已被释放，同时前次写线程的修改对后续线程可见。</p><h3 id="3-读锁的获取和释放"><a href="#3-读锁的获取和释放" class="headerlink" title="3. 读锁的获取和释放"></a>3. 读锁的获取和释放</h3><p>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问（或者写状态为0）时，读锁总后被成功的获取，而所做的也只有（线程安全的）增加读状态。如果当前线程已获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。</p><h3 id="4-锁降级"><a href="#4-锁降级" class="headerlink" title="4. 锁降级"></a>4. 锁降级</h3><p>锁降级指的是写锁降级称为读锁。如果当前线程拥有写锁，然后将其释放，最后在获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指吧当前把持住（当前拥有的）写锁，在获取到读锁，随后释放（先前拥有的）写锁的过程。</p><p>接下来看一个锁降级的示例。因为数据不常变化，所以多个线程可能并发地进行数据处理，当数据变更后，如果当前线程感知到数据变化，则进行数据准备工作，同时其他处理线程被阻塞，知道当前线程完成数据准备工作，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    readLock.lock();</span><br><span class="line">    <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">        <span class="comment">// 必须先释放读锁</span></span><br><span class="line">        readLock.unlokc();</span><br><span class="line">        <span class="comment">// 锁降级从写锁的获取开始</span></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">                <span class="comment">// 准备数据的流程（略）</span></span><br><span class="line">                update = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            readLock.lock();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 锁降级完成，写锁降级为读锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 使用数据的流程（略）</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        readLock.unLock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例中，当数据发生变更后，uodate变量（布尔类型且volatile修饰）被设置为false，此时所有访问processDate()方法的线程都能感知到变化，且只有一个线程能够获得到写锁，其他线程会被阻塞在读锁和写锁的lock()方法上。当前线程获取写锁完成数据准备之后，在获取读锁，随后释放写锁，完成锁降级。</p><p>锁降级中读锁的获取是否有必要呢？答案是必要的。主要是为了保证线程数据的可见性，如果当前线程不是获取读锁是指直接获取写锁，假设此刻另一个线程（记做线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，线程T将会被阻塞，知道当前线程释放读锁之后，线程T才能进行数据的更新。</p><h2 id="4-实现源码分析"><a href="#4-实现源码分析" class="headerlink" title="4. 实现源码分析"></a>4. 实现源码分析</h2><h3 id="1-ReentrantReadWriteLock的继承关系"><a href="#1-ReentrantReadWriteLock的继承关系" class="headerlink" title="1. ReentrantReadWriteLock的继承关系"></a>1. ReentrantReadWriteLock的继承关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>ReentrantReadWriteLock继承了上面所说的ReadWriteLock。</p><h3 id="2-ReentrantReadWriteLock中的变量"><a href="#2-ReentrantReadWriteLock中的变量" class="headerlink" title="2. ReentrantReadWriteLock中的变量"></a>2. ReentrantReadWriteLock中的变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Inner class providing readlock */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line"><span class="comment">/** Inner class providing writelock */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line"><span class="comment">/** Performs all synchronization mechanics */</span></span><br><span class="line"><span class="keyword">final</span> Sync sync;</span><br></pre></td></tr></table></figure><p>ReadLock，WriteLock，Sync都是ReentrantReadWriteLock中的内部类。ReadLock是读锁，WriteLock是写锁，Sync是ReentrantReadWriteLock实现的关键。</p><h3 id="3-ReentrantReadWriteLock的构造函数"><a href="#3-ReentrantReadWriteLock的构造函数" class="headerlink" title="3. ReentrantReadWriteLock的构造函数"></a>3. ReentrantReadWriteLock的构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">    writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到ReentrantReadWriteLock中也有公平锁和非公平锁，ReentrantReadWriteLock中默认的是非公平锁。</p><h3 id="4-ReentrantReadWriteLock的内部类"><a href="#4-ReentrantReadWriteLock的内部类" class="headerlink" title="4. ReentrantReadWriteLock的内部类"></a>4. ReentrantReadWriteLock的内部类</h3><p>从上面我们知道AQS的状态state是一个int的值，在读写锁中，它的高16为用来计数读锁，低16位用来计数写锁，它们各自共有65535个状态， 2^16-1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6317671515068378041L</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Read vs write count extraction constants and functions.</span></span><br><span class="line"><span class="comment">     * Lock state is logically divided into two unsigned shorts:</span></span><br><span class="line"><span class="comment">     * The lower one representing the exclusive (writer) lock hold count,</span></span><br><span class="line"><span class="comment">     * and the upper the shared (reader) hold count.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 分隔的位数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 用于读锁的高位部分，将1左移16位</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 写锁的掩码，用于状态的低16值有效 高16位全0，第16位全1</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/** Returns the number of shared holds represented in count  */</span></span><br><span class="line">    <span class="comment">// 计算 readLock 的获取次数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">    <span class="comment">/** Returns the number of exclusive holds represented in count  */</span></span><br><span class="line">    <span class="comment">// 计算 writeLock 的获取次数，把c与EXCLUSIVE_MASK(高16位全0，第16位全1)做与</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A counter for per-thread read hold counts.</span></span><br><span class="line"><span class="comment">     * Maintained as a ThreadLocal; cached in cachedHoldCounter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 几乎每个获取readLock的线程都会包含一个HoldCounter用来记录 线程id与获取readLock的次数</span></span><br><span class="line"><span class="comment">     * writeLock 的获取是由state的低位 及 AQS中的exclusiveOwnerThread 来进行记录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// Use id, not reference, to avoid garbage retention</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ThreadLocal subclass. Easiest to explicitly define for sake</span></span><br><span class="line"><span class="comment">     * of deserialization mechanics.</span></span><br><span class="line"><span class="comment">     * ThreadLockHoldCounter继承了ThreadLocl，这里的继承主要是为了重写initialValue()这个方法</span></span><br><span class="line"><span class="comment">     * 重写ThreadLocl的initialValue()方法的作用是：使得这个类的对象可以直接get()不用先set再get</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of reentrant read locks held by current thread.</span></span><br><span class="line"><span class="comment">     * Initialized only in constructor and readObject.</span></span><br><span class="line"><span class="comment">     * Removed whenever a thread's read hold count drops to 0.</span></span><br><span class="line"><span class="comment"> * 当前线程持有可重入读锁的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The hold count of the last thread to successfully acquire</span></span><br><span class="line"><span class="comment">     * readLock. This saves ThreadLocal lookup in the common case</span></span><br><span class="line"><span class="comment">     * where the next thread to release is the last one to</span></span><br><span class="line"><span class="comment">     * acquire. This is non-volatile since it is just used</span></span><br><span class="line"><span class="comment">     * as a heuristic, and would be great for threads to cache.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Can outlive the Thread for which it is caching the read</span></span><br><span class="line"><span class="comment">     * hold count, but avoids garbage retention by not retaining a</span></span><br><span class="line"><span class="comment">     * reference to the Thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Accessed via a benign data race; relies on the memory</span></span><br><span class="line"><span class="comment">     * model's final field and out-of-thin-air guarantees.</span></span><br><span class="line"><span class="comment">     * 最近一个成功获取可重入读锁的数量，这省却了ThreadLocl的查找</span></span><br><span class="line"><span class="comment">     * 通常情况下，下一个释放的线程是最后一个获取线程，这不是volatile的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * firstReader is the first thread to have acquired the read lock.</span></span><br><span class="line"><span class="comment">     * firstReaderHoldCount is firstReader's hold count.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;More precisely, firstReader is the unique thread that last</span></span><br><span class="line"><span class="comment">     * changed the shared count from 0 to 1, and has not released the</span></span><br><span class="line"><span class="comment">     * read lock since then; null if there is no such thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Cannot cause garbage retention unless the thread terminated</span></span><br><span class="line"><span class="comment">     * without relinquishing its read locks, since tryReleaseShared</span></span><br><span class="line"><span class="comment">     * sets it to null.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Accessed via a benign data race; relies on the memory</span></span><br><span class="line"><span class="comment">     * model's out-of-thin-air guarantees for references.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This allows tracking of read holds for uncontended read</span></span><br><span class="line"><span class="comment">     * locks to be very cheap.</span></span><br><span class="line"><span class="comment">     * 第一个获取读锁的线程</span></span><br><span class="line"><span class="comment">     * firstReaderHoldCount持有的是firstReader</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br><span class="line">    Sync() &#123;</span><br><span class="line">        readHolds = <span class="keyword">new</span> ThreadLocalHoldCounter();</span><br><span class="line">        setState(getState()); <span class="comment">// ensures visibility of readHolds</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Acquires and releases use the same code for fair and</span></span><br><span class="line"><span class="comment">     * nonfair locks, but differ in whether/how they allow barging</span></span><br><span class="line"><span class="comment">     * when queues are non-empty.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if the current thread, when trying to acquire</span></span><br><span class="line"><span class="comment">     * the read lock, and otherwise eligible to do so, should block</span></span><br><span class="line"><span class="comment">     * because of policy for overtaking other waiting threads.</span></span><br><span class="line"><span class="comment">     * 读锁是否需要阻塞</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if the current thread, when trying to acquire</span></span><br><span class="line"><span class="comment">     * the write lock, and otherwise eligible to do so, should block</span></span><br><span class="line"><span class="comment">     * because of policy for overtaking other waiting threads.</span></span><br><span class="line"><span class="comment">     * 写锁是否需要被阻塞</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Note that tryRelease and tryAcquire can be called by</span></span><br><span class="line"><span class="comment">     * Conditions. So it is possible that their arguments contain</span></span><br><span class="line"><span class="comment">     * both read and write holds that are all released during a</span></span><br><span class="line"><span class="comment">     * condition wait and re-established in tryAcquire.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前线程是否获取独占锁的线程</span></span><br><span class="line">        <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="comment">// 进行state的释放操作</span></span><br><span class="line">        <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">        <span class="comment">// 判断exclusive lock（写锁）是否释放完</span></span><br><span class="line">        <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 释放完毕</span></span><br><span class="line">        <span class="keyword">if</span> (free)</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Walkthrough:</span></span><br><span class="line"><span class="comment">         * 1. If read count nonzero or write count nonzero</span></span><br><span class="line"><span class="comment">         *    and owner is a different thread, fail.</span></span><br><span class="line"><span class="comment">         * 2. If count would saturate, fail. (This can only</span></span><br><span class="line"><span class="comment">         *    happen if count is already nonzero.)</span></span><br><span class="line"><span class="comment">         * 3. Otherwise, this thread is eligible for lock if</span></span><br><span class="line"><span class="comment">         *    it is either a reentrant acquire or</span></span><br><span class="line"><span class="comment">         *    queue policy allows it. If so, update state</span></span><br><span class="line"><span class="comment">         *    and set owner.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 写锁的数量</span></span><br><span class="line">        <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">        <span class="comment">// 如果c不为0，则写锁不能获取</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">            <span class="comment">// 如果写锁的数量为0，当前线程不是独占线程，那么说明是读锁占着当前线程</span></span><br><span class="line">            <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 否则的话判断是否能加锁</span></span><br><span class="line">            <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            <span class="comment">// Reentrant acquire</span></span><br><span class="line">            setState(c + acquires);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果写锁应该被阻塞或者设置CAS失败</span></span><br><span class="line">        <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">            !compareAndSetState(c, c + acquires))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 把当前线程设置为独占线程</span></span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="comment">// 判断现在进行释放的release的线程是不是 firstReader</span></span><br><span class="line">        <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">            <span class="comment">// 如果firstReaderHoldCount中的值为1，也就是获取了一次读锁，那么直接释放</span></span><br><span class="line">            <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">                firstReader = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                firstReaderHoldCount--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前线程不是firstReader，那么获取缓存中的HoldCounter</span></span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="comment">// 如果缓存不为空，或者当前线程的id是不是缓存的id</span></span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                <span class="comment">// 那么从当前线程的线程局部变量中的readHolds</span></span><br><span class="line">                rh = readHolds.get();</span><br><span class="line">            <span class="keyword">int</span> count = rh.count;</span><br><span class="line">            <span class="comment">// 如果当前线程中的读锁的数量&lt;=1，那么把当前线程中的HoldCounter释放</span></span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                readHolds.remove();</span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">            &#125;</span><br><span class="line">            --rh.count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="comment">// 读锁的数量减1，那么也就是减SHARED_UNIT（SHARED_UNIT第17位为1，其余为0）</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">            <span class="comment">// cas</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">                <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">                <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">                <span class="comment">// 返回值是判断 是否还有 readLock 没有释放完, 当释放完了会进行 后继节点的 唤醒( readLock 在进行获取成功时也进行传播式的唤醒后继的 获取 readLock 的节点)</span></span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> IllegalMonitorStateException <span class="title">unmatchedUnlockException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IllegalMonitorStateException(</span><br><span class="line">            <span class="string">"attempt to unlock read lock, not locked by current thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Walkthrough:</span></span><br><span class="line"><span class="comment">         * 1. If write lock held by another thread, fail.</span></span><br><span class="line"><span class="comment">         * 2. Otherwise, this thread is eligible for</span></span><br><span class="line"><span class="comment">         *    lock wrt state, so ask if it should block</span></span><br><span class="line"><span class="comment">         *    because of queue policy. If not, try</span></span><br><span class="line"><span class="comment">         *    to grant by CASing state and updating count.</span></span><br><span class="line"><span class="comment">         *    Note that step does not check for reentrant</span></span><br><span class="line"><span class="comment">         *    acquires, which is postponed to full version</span></span><br><span class="line"><span class="comment">         *    to avoid having to check hold count in</span></span><br><span class="line"><span class="comment">         *    the more typical non-reentrant case.</span></span><br><span class="line"><span class="comment">         * 3. If step 2 fails either because thread</span></span><br><span class="line"><span class="comment">         *    apparently not eligible or CAS fails or count</span></span><br><span class="line"><span class="comment">         *    saturated, chain to version with full retry loop.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 如果当前线程获取写锁并且获取写锁的线程不是当前线程，那么返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            getExclusiveOwnerThread() != current)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 获取读锁的数量</span></span><br><span class="line">        <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">        <span class="comment">// 如果读锁不用被阻塞，并且读锁的数量小于MAX_COUNT</span></span><br><span class="line">        <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">            r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">            <span class="comment">// 读锁的状态加1</span></span><br><span class="line">            compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="comment">// 如果是第一个获取读锁的，那么设置firstReader和firstReaderHoldCount</span></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果firstReader出当前线程，那么肯定是读锁重入</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">// 第一个读锁重入的次数++</span></span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 获取缓存</span></span><br><span class="line">                HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                <span class="comment">// 如果HoldCounter中存储的不是当前的线程</span></span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    <span class="comment">// 更新缓存</span></span><br><span class="line">                    cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Full version of acquire for reads, that handles CAS misses</span></span><br><span class="line"><span class="comment">     * and reentrant reads not dealt with in tryAcquireShared.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * This code is part redundant with that in</span></span><br><span class="line"><span class="comment">      * tryAcquireShared but is simpler overall by not</span></span><br><span class="line"><span class="comment">      * complicating tryAcquireShared with interactions between</span></span><br><span class="line"><span class="comment">      * retries and lazily reading hold counts</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="keyword">int</span> c= getState();</span><br><span class="line">        <span class="keyword">if</span>(exclusiveCount(c) != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(getExclusiveOwnerThread() != current)           <span class="comment">// 1. 若此刻 有其他的线程获取了 writeLock 则直接进行 return 到 aqs 的 sync queue 里面</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// else we hold the exclusive lock; blocking here</span></span><br><span class="line">            <span class="comment">// would cause deadlock</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(readerShouldBlock())&#123;                        <span class="comment">// 2. 判断 获取 readLock 的策略</span></span><br><span class="line">            <span class="comment">// Make sure we're not acquiring read lock reentrantly</span></span><br><span class="line">            <span class="keyword">if</span>(firstReader == current)&#123;                       <span class="comment">// 3. 若是 readLock 的 重入获取, 则直接进行下面的 CAS 操作</span></span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(rh == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span>(rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))&#123;</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">if</span>(rh.count == <span class="number">0</span>)&#123;</span><br><span class="line">                            readHolds.remove();               <span class="comment">// 4. 若 rh.count == 0 进行 ThreadLocal.remove</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(rh.count == <span class="number">0</span>)&#123;                            <span class="comment">// 5.  count != 0 则说明这次是 readLock 获取锁的 重入(reentrant), 所以即使出现死锁, 以前获取过 readLock 的线程还是能继续 获取 readLock</span></span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;                                <span class="comment">// 6. 进行到这一步只有 当 aqs sync queue 里面有 获取 readLock 的node 或 head.next 是获取 writeLock 的节点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sharedCount(c) == MAX_COUNT)&#123;                      <span class="comment">// 7. 是否获取 锁溢出</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(compareAndSetState(c, c + SHARED_UNIT))&#123;          <span class="comment">// 8.  CAS 可能会失败, 但没事, 我们这边外围有个 for loop 来进行保证 操作一定进行</span></span><br><span class="line">            <span class="keyword">if</span>(sharedCount(c) == <span class="number">0</span>)&#123;                         <span class="comment">//  9. r == 0 没有线程获取 readLock 直接对 firstReader firstReaderHoldCount 进行初始化</span></span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(firstReader == current)&#123;                <span class="comment">// 10. 第一个获取 readLock 的是 current 线程, 直接计数器加 1</span></span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(rh == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))&#123;</span><br><span class="line">                    rh = readHolds.get();                    <span class="comment">// 11. 还是上面的逻辑, 先从 cachedHoldCounter, 数据不对的话, 再从readHolds拿数据</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rh.count == <span class="number">0</span>)&#123;</span><br><span class="line">                    readHolds.set(rh);                       <span class="comment">// 12. 为什么要 count == 0 时进行 ThreadLocal.set? 因为上面 tryReleaseShared方法 中当 count == 0 时, 进行了ThreadLocal.remove</span></span><br><span class="line">               &#125;</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh; <span class="comment">// cache for release // 13. 获取成功</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs tryLock for write, enabling barging in both modes.</span></span><br><span class="line"><span class="comment">     * This is identical in effect to tryAcquire except for lack</span></span><br><span class="line"><span class="comment">     * of calls to writerShouldBlock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">            <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (w == MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetState(c, c + <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        setExclusiveOwnerThread(current);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs tryLock for read, enabling barging in both modes.</span></span><br><span class="line"><span class="comment">     * This is identical in effect to tryAcquireShared except for</span></span><br><span class="line"><span class="comment">     * lack of calls to readerShouldBlock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">            <span class="keyword">if</span> (r == MAX_COUNT)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// While we must in general read state before owner,</span></span><br><span class="line">        <span class="comment">// we don't need to do so to check if current thread is owner</span></span><br><span class="line">        <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Methods relayed to outer class</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> Thread <span class="title">getOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Must read state before owner to ensure memory consistency</span></span><br><span class="line">        <span class="keyword">return</span> ((exclusiveCount(getState()) == <span class="number">0</span>) ?</span><br><span class="line">                <span class="keyword">null</span> :</span><br><span class="line">                getExclusiveOwnerThread());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getReadLockCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sharedCount(getState());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isWriteLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exclusiveCount(getState()) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getWriteHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isHeldExclusively() ? exclusiveCount(getState()) : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getReadHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getReadLockCount() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (firstReader == current)</span><br><span class="line">            <span class="keyword">return</span> firstReaderHoldCount;</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh != <span class="keyword">null</span> &amp;&amp; rh.tid == getThreadId(current))</span><br><span class="line">            <span class="keyword">return</span> rh.count;</span><br><span class="line">        <span class="keyword">int</span> count = readHolds.get().count;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) readHolds.remove();</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reconstitutes the instance from a stream (that is, deserializes it).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        readHolds = <span class="keyword">new</span> ThreadLocalHoldCounter();</span><br><span class="line">        setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> getState(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ReentrantReadWriteLock-分析&quot;&gt;&lt;a href=&quot;#ReentrantReadWriteLock-分析&quot; class=&quot;headerlink&quot; title=&quot;ReentrantReadWriteLock 分析&quot;&gt;&lt;/a&gt;ReentrantRe
      
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
      <category term="读写锁" scheme="http://yoursite.com/tags/%E8%AF%BB%E5%86%99%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot中的数据校验</title>
    <link href="http://yoursite.com/2019/04/08/SpringBoot%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/"/>
    <id>http://yoursite.com/2019/04/08/SpringBoot中的数据校验/</id>
    <published>2019-04-08T10:50:00.000Z</published>
    <updated>2019-04-11T00:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-Boot中的数据校验"><a href="#Spring-Boot中的数据校验" class="headerlink" title="Spring Boot中的数据校验"></a>Spring Boot中的数据校验</h2><p>我们可能会经常需要对传入的参数进行校验，如果数据比较少的时候还比较容易处理，但当数据比较多的时候会显得比较麻烦，而且处理不当的时候，还会代码重复。这时候就需要Spring Boot对参数进行校验了。<br>这时候就需要使用使用Validation对数据进行校验了。</p><h3 id="在Spring-Boot中使用Validation"><a href="#在Spring-Boot中使用Validation" class="headerlink" title="在Spring Boot中使用Validation"></a>在Spring Boot中使用Validation</h3><p>有如下的一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/book"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">getBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到请求传入了一个Book，Book类如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line">    <span class="keyword">private</span> String bookAuthor;</span><br><span class="line">    <span class="comment">// 省略get和set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在需要对book中的属性进行校验，如果使用if else 进行校验会显得很麻烦。这时候可以在Book中的属性上添加Validation注解，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line">    <span class="meta">@NotBlank</span></span><br><span class="line">    <span class="keyword">private</span> String bookAuthor;</span><br><span class="line">    <span class="comment">// 省略get和set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中的NotBlank注解指的是属性值不能为空。<br>然后还需要在Controller中的方法的需要校验的字段上加上@Valid注解，表明这个参数需要校验，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/book"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">getBook</span><span class="params">(@Valid Book book)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时候假如bookName和bookAuthor为空，那么就会出现400的响应码。<br><img src="https://img-blog.csdn.net/2018072511041365?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0YXJleHBsb2Rl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>Spring Boot这时的返回为：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"timestamp"</span>: <span class="string">"2018-07-25T01:21:53.644+0000"</span>,</span><br><span class="line">    <span class="attr">"status"</span>: <span class="number">400</span>,</span><br><span class="line">    <span class="attr">"error"</span>: <span class="string">"Bad Request"</span>,</span><br><span class="line">    <span class="attr">"errors"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"codes"</span>: [</span><br><span class="line">                <span class="string">"NotBlank.book.bookAuthor"</span>,</span><br><span class="line">                <span class="string">"NotBlank.bookAuthor"</span>,</span><br><span class="line">                <span class="string">"NotBlank.java.lang.String"</span>,</span><br><span class="line">                <span class="string">"NotBlank"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"arguments"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"codes"</span>: [</span><br><span class="line">                        <span class="string">"book.bookAuthor"</span>,</span><br><span class="line">                        <span class="string">"bookAuthor"</span></span><br><span class="line">                    ],</span><br><span class="line">                    <span class="attr">"arguments"</span>: <span class="literal">null</span>,</span><br><span class="line">                    <span class="attr">"defaultMessage"</span>: <span class="string">"bookAuthor"</span>,</span><br><span class="line">                    <span class="attr">"code"</span>: <span class="string">"bookAuthor"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"defaultMessage"</span>: <span class="string">"不能为空"</span>,</span><br><span class="line">            <span class="attr">"objectName"</span>: <span class="string">"book"</span>,</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"bookAuthor"</span>,</span><br><span class="line">            <span class="attr">"rejectedValue"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="attr">"bindingFailure"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"code"</span>: <span class="string">"NotBlank"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"codes"</span>: [</span><br><span class="line">                <span class="string">"NotBlank.book.bookName"</span>,</span><br><span class="line">                <span class="string">"NotBlank.bookName"</span>,</span><br><span class="line">                <span class="string">"NotBlank.java.lang.String"</span>,</span><br><span class="line">                <span class="string">"NotBlank"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"arguments"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"codes"</span>: [</span><br><span class="line">                        <span class="string">"book.bookName"</span>,</span><br><span class="line">                        <span class="string">"bookName"</span></span><br><span class="line">                    ],</span><br><span class="line">                    <span class="attr">"arguments"</span>: <span class="literal">null</span>,</span><br><span class="line">                    <span class="attr">"defaultMessage"</span>: <span class="string">"bookName"</span>,</span><br><span class="line">                    <span class="attr">"code"</span>: <span class="string">"bookName"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"defaultMessage"</span>: <span class="string">"不能为空"</span>,</span><br><span class="line">            <span class="attr">"objectName"</span>: <span class="string">"book"</span>,</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"bookName"</span>,</span><br><span class="line">            <span class="attr">"rejectedValue"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="attr">"bindingFailure"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"code"</span>: <span class="string">"NotBlank"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"Validation failed for object='book'. Error count: 2"</span>,</span><br><span class="line">    <span class="attr">"path"</span>: <span class="string">"/book"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为使用的是测试工具，所以Spring Boot返回的是Json串。<br>上面的是Spring Boot的默认返回，我们肯定不希望返回这样的一个东西给前端。所以就需要自定义错误信息和错误处理。</p><h3 id="自定义校验信息和错误处理"><a href="#自定义校验信息和错误处理" class="headerlink" title="自定义校验信息和错误处理"></a>自定义校验信息和错误处理</h3><p>Validation注解中都有一个message的属性可以通过这个属性自定义错误信息。如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"书名不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line">    <span class="meta">@NotBlank</span>(message = <span class="string">"作者不能为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String bookAuthor;</span><br><span class="line">    <span class="comment">// 省略get和set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Spring Boot的Controller方法中可以传一个BindingResult或者Errors类型的参数，<strong>值得注意的一点是这个参数的位置必须是参数列表的被<code>@Valid</code>注解修饰的参数紧跟着的（也就是被<code>@Valid修饰的下一个参数</code>）后面，如果在前面，会出现下面的错误，如果不是下一个，那么这个参数将不起作用</strong>。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"timestamp"</span>: <span class="string">"2018-07-25T01:49:10.742+0000"</span>,</span><br><span class="line">    <span class="attr">"status"</span>: <span class="number">500</span>,</span><br><span class="line">    <span class="attr">"error"</span>: <span class="string">"Internal Server Error"</span>,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"An Errors/BindingResult argument is expected to be declared immediately after the model attribute, the @RequestBody or the @RequestPart arguments to which they apply: public top.mcwebsite.demo.domain.Book top.mcwebsite.demo.web.controller.BookController.getBook(org.springframework.validation.BindingResult,top.mcwebsite.demo.domain.Book,javax.servlet.http.HttpServletResponse)"</span>,</span><br><span class="line">    <span class="attr">"path"</span>: <span class="string">"/book"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面的代码是如何进行自定义错误处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/book"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">getBook</span><span class="params">(@Valid Book book, BindingResult result, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">            result.getAllErrors().forEach((error) -&gt; &#123;</span><br><span class="line">                FieldError fieldError = (FieldError) error;</span><br><span class="line">                <span class="comment">// 属性</span></span><br><span class="line">                String field = fieldError.getField();</span><br><span class="line">                <span class="comment">// 错误信息</span></span><br><span class="line">                String message = fieldError.getDefaultMessage();</span><br><span class="line">                System.out.println(field + <span class="string">":"</span> + message);</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> book;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果：<br><img src="https://img-blog.csdn.net/20180725110435519?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0YXJleHBsb2Rl/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>这里的错处处理只是简单的打印。</p><p>这里的错误消息也可以做成国际化的，具体做法可以自己取研究。</p><p>当需要校验的Bean比较多的时候这样也会显得比较麻烦，所以这时候就可以使用Spring Boot的异常处理机制了。</p><h3 id="Spring-Boot的异常处理＋Bean-Validation"><a href="#Spring-Boot的异常处理＋Bean-Validation" class="headerlink" title="Spring Boot的异常处理＋Bean Validation"></a>Spring Boot的异常处理＋Bean Validation</h3><p>Spring　Boot 中有一个专门处理错误信息的一个类叫做ResponseEntityExceptionHandler。其中有很多关于400的错误处理，也就是参数错误的处理，其中就有一个专门用来处理没有通过校验的参数的方法。我们重写这个类的这个方法即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span>   <span class="comment">// Spring 的异常处理的注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BadRequestExceptionHandler</span> <span class="keyword">extends</span> <span class="title">ResponseEntityExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ResponseEntity&lt;Object&gt; <span class="title">handleBindException</span><span class="params">(BindException ex, HttpHeaders headers, HttpStatus status, WebRequest request)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; messages = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        BindingResult result = ex.getBindingResult();</span><br><span class="line">        <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">            List&lt;ObjectError&gt; errors = result.getAllErrors();</span><br><span class="line">            <span class="keyword">for</span> (ObjectError error : errors) &#123;</span><br><span class="line">                FieldError fieldError = (FieldError) error;</span><br><span class="line">                messages.put(fieldError.getField(), fieldError.getDefaultMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            logger.error(messages.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.status(HttpStatus.BAD_REQUEST).body(messages);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时候controller中的方法中就不需要BindingResult或者Errors类型的参数了。</p><h3 id="一些常用的Validation注解"><a href="#一些常用的Validation注解" class="headerlink" title="一些常用的Validation注解"></a>一些常用的Validation注解</h3><table><thead><tr><th style="text-align:left">注解</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">@NotNull</td><td style="text-align:left">值不能为空</td></tr><tr><td style="text-align:left">@Null</td><td style="text-align:left">值必须为空</td></tr><tr><td style="text-align:left">@Pattern(regex=)</td><td style="text-align:left">字符串必须匹配正则表达式</td></tr><tr><td style="text-align:left">@Size(min, max)</td><td style="text-align:left">集合元素的数量必须在min和max之间</td></tr><tr><td style="text-align:left">@CreditCardNumber(ignoreNonDigitCharacters=)</td><td style="text-align:left">字符串必须是信用卡号，按找美国的标准验证</td></tr><tr><td style="text-align:left">@Email</td><td style="text-align:left">字符串必须是Email地址</td></tr><tr><td style="text-align:left">@Length(min, max)</td><td style="text-align:left">检查字符串的长度</td></tr><tr><td style="text-align:left">@NotBlank</td><td style="text-align:left">字符串不能为空串</td></tr><tr><td style="text-align:left">@NotEmpty</td><td style="text-align:left">字符串不能为null, 集合必须有元素</td></tr><tr><td style="text-align:left">@Range(min, max)</td><td style="text-align:left">数字必须大于min, 小于max</td></tr><tr><td style="text-align:left">@SafeHtml</td><td style="text-align:left">字符串必须是安全的html</td></tr><tr><td style="text-align:left">@URL</td><td style="text-align:left">字符串必须是合法的URL</td></tr><tr><td style="text-align:left">@AssertFalse</td><td style="text-align:left">值必须是false</td></tr><tr><td style="text-align:left">@AssertTrue</td><td style="text-align:left">值必须是true</td></tr><tr><td style="text-align:left">@DecimalMax(value=, inclusive=)</td><td style="text-align:left">值必须小于等于(inclusive=true)/小于(inclusive=false)属性指定的值，也可以注释在字符串类型的属性上。</td></tr><tr><td style="text-align:left">@DecimalMin(value=, inclusive=)</td><td style="text-align:left">值必须大于等于(inclusive=true)/小于(inclusive=false)属性指定的值，也可以注释在字符串类型的属性上。</td></tr><tr><td style="text-align:left">@Digist(integer=,fraction=)</td><td style="text-align:left">数字格式检查。integer指定整数部分的最大长度，fraction指定小数部分的最大长度</td></tr><tr><td style="text-align:left">@Future</td><td style="text-align:left">时间必须是未来的</td></tr><tr><td style="text-align:left">@Past</td><td style="text-align:left">事件必须是过去的</td></tr><tr><td style="text-align:left">@Max(value=)</td><td style="text-align:left">值必须小于等于value指定的值。不能注解在字符串类型属性上。</td></tr><tr><td style="text-align:left">@Min(value=)</td><td style="text-align:left">值必须小于等于value指定的值。不能注解在字符串类型属性上。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-Boot中的数据校验&quot;&gt;&lt;a href=&quot;#Spring-Boot中的数据校验&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot中的数据校验&quot;&gt;&lt;/a&gt;Spring Boot中的数据校验&lt;/h2&gt;&lt;p&gt;我们可能会经常需要对
      
    
    </summary>
    
      <category term="spring" scheme="http://yoursite.com/categories/spring/"/>
    
    
      <category term="spring" scheme="http://yoursite.com/tags/spring/"/>
    
      <category term="校验" scheme="http://yoursite.com/tags/%E6%A0%A1%E9%AA%8C/"/>
    
      <category term="Validation" scheme="http://yoursite.com/tags/Validation/"/>
    
  </entry>
  
  <entry>
    <title>Java并发之无锁</title>
    <link href="http://yoursite.com/2019/04/07/Java%E5%B9%B6%E5%8F%91%E4%B9%8B%E6%97%A0%E9%94%81/"/>
    <id>http://yoursite.com/2019/04/07/Java并发之无锁/</id>
    <published>2019-04-07T10:50:00.000Z</published>
    <updated>2019-04-09T00:22:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java并发编程之无锁"><a href="#Java并发编程之无锁" class="headerlink" title="Java并发编程之无锁"></a>Java并发编程之无锁</h1><p>在谈论无所之前先来看看乐观派和悲观派。对于乐观派而言，他们总认为事情总会朝着好的方向发展，总认为几乎不会坏事，我已可以随意的去做事。但是对于悲观派来说，他们认为出错是一种常态，所以无论事情大小都会考虑的面面俱到，滴水不漏。</p><p>在两种派别对应在并发中就是加锁和无锁，也就是说加锁是一种悲观的策略，而无锁是一种乐观的策略。对于锁，如果有多个线程同事访问一个临界资源，宁可牺牲性能让线程等待，也不会让一个线程不加锁访问临界资源。对于无锁，它会假定对资源的访问是没有冲突的。也就是多个线程对临界资源的访问是没有冲突的。既然没有冲突，那么就不需要等待，所有的线程都可以不需要等待的执行下去。如果遇到了冲突，怎么办？这里无锁策略使用了一种称为CAS的技术来保证线程执行的安全性。下面我们来具体讨论一下CAS。</p><h2 id="无锁解决冲突的办法：CAS"><a href="#无锁解决冲突的办法：CAS" class="headerlink" title="无锁解决冲突的办法：CAS"></a>无锁解决冲突的办法：CAS</h2><p>CAS的全称是Compare And Swap即比较和交换。</p><p>CAS算法的过程是这样的：它包含三个参数的变量CAS(V, E, N)。作用如下：</p><ul><li>V 表示要更新的值。</li><li>E 表示预期的值。</li><li>N 表示新值。</li></ul><p><strong>仅当V值等于E值的，才会将V值设置为N值</strong>，如果V值和E值不同，则说明已经有其他线程做了更新，当前线程什么都不做。CVS返回的是当前V的真实值。<br>CAS是乐观派，总认为自己可以操作成功。当多个线程同时使用CAS来给一个变量设置时，只有一个会成功，其它的都会失败，但是CAS很乐观，失败了就失败了，可以再次尝试。</p><h2 id="Java中的指针：Unsafe类"><a href="#Java中的指针：Unsafe类" class="headerlink" title="Java中的指针：Unsafe类"></a>Java中的指针：Unsafe类</h2><p>What? Java中也有指针。Unsfae类就像它的名字一样，不安全，里面有一些向C语言的指针一样直接操作内存的方法。并且官方也不推荐直接使用Unsafe类。但是CAS的实现用到了这个类。<br>下面来看看Unsafe中的一些方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">allocateMemory</span><span class="params">(<span class="keyword">long</span> var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新分配内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">reallocateMemory</span><span class="params">(<span class="keyword">long</span> var1, <span class="keyword">long</span> var3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">copyMemory</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, <span class="keyword">long</span> var5, <span class="keyword">long</span> var7)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">freeMemory</span><span class="params">(<span class="keyword">long</span> var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取起始地址</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">getAddress</span><span class="params">(<span class="keyword">long</span> var1)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取操作系统内存页大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">pageSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>Unsafe中有两个方法可以将线程挂起和恢复，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程调用方法，将线程挂起</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object var1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程恢复</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> var1, <span class="keyword">long</span> var2)</span></span>;</span><br></pre></td></tr></table></figure><p>Unsafe中的关于CAS的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var6)</span></span>;</span><br></pre></td></tr></table></figure><p>CAS的操作的核心实现是这三个方法。<br>三个方法的参数都类似，分别为：</p><ol><li>CAS需要更改变量的对象；</li><li>对象内存的偏移量;</li><li>期望值</li><li>需要设置的值</li></ol><p>其中偏移量可以通过Unsafe类中的objectFieldOffset()方法获取到，这些方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">objectFieldOffset</span><span class="params">(Field field)</span></span>;</span><br></pre></td></tr></table></figure><p>因为int，long，boolean类型的相关操作不是原子性的，所以JDK在1.5之后提供了atomic包（具体在<code>java.util.concurrent.atomic</code>中）来将这些操作变成原子操作。</p><p>下面的图片中的是atomic下提供的原子操作的类：<br><img src="https://img-blog.csdn.net/20181017155907620" alt="image.png"></p><p>这里以AtomicInteger来进行分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">public class AtomicInteger extends Number implements java.io.Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    // 实例化Unsafe</span><br><span class="line">    private static final Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    </span><br><span class="line">    // valueOffset变量保存的是value中的偏移量，这一点可以在下面的static初始化块中可以看出</span><br><span class="line">    private static final long valueOffset;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 获取value的偏移量</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));</span><br><span class="line">        &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private volatile int value;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 通过int值实例化一个AtomicInteger对象</span><br><span class="line">     */</span><br><span class="line">    public AtomicInteger(int initialValue) &#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 实例化一个AtomicInteger对象，其初始值为0</span><br><span class="line">     */</span><br><span class="line">    public AtomicInteger() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 获取当前值</span><br><span class="line">    public final int get() &#123;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    // 设置当前值</span><br><span class="line">    public final void set(int newValue) &#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 延迟设值</span><br><span class="line">    public final void lazySet(int newValue) &#123;</span><br><span class="line">        unsafe.putOrderedInt(this, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置新值获取旧值</span><br><span class="line">    public final int getAndSet(int newValue) &#123;</span><br><span class="line">        return unsafe.getAndSetInt(this, valueOffset, newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // CAS操作，把当前值和预期值做比较，相当时设置新值</span><br><span class="line">    public final boolean compareAndSet(int expect, int update) &#123;</span><br><span class="line">        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public final boolean weakCompareAndSet(int expect, int update) &#123;</span><br><span class="line">        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 当前值加1，返回旧值</span><br><span class="line">    public final int getAndIncrement() &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 当前值-1，返回旧值</span><br><span class="line">    public final int getAndDecrement() &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, -1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 当前值加上delta，然后返回旧值</span><br><span class="line">    public final int getAndAdd(int delta) &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 当前值加1，然后返回</span><br><span class="line">    public final int incrementAndGet() &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 当前值减1，返回返回</span><br><span class="line">    public final int decrementAndGet() &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, -1) - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 当前值加上delta，然后返回</span><br><span class="line">    public final int addAndGet(int delta) &#123;</span><br><span class="line">        return unsafe.getAndAddInt(this, valueOffset, delta) + delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的大部分方法都直接或者间接使用了CAS来保证安全。</p><p>除了上面的对于基本变量的Atomic类，还有关于普通对象引用的Atmoic类。</p><h2 id="AtomicReference-无锁的引用"><a href="#AtomicReference-无锁的引用" class="headerlink" title="AtomicReference 无锁的引用"></a>AtomicReference 无锁的引用</h2><p>AtomicReference和AtmoicInteger非常类似，不同之处就是AtmoicInteger是对整数的封装，而AtmoicReference是对普通对象的引用，也就是它可以保证在修改对象引用时线程的安全性。</p><p>CAS中有一个很重要的问题ABA。CAS比较的是对象中的值和期望值，但是有可能在你获取到当前对象的数据后，在准备修改为新值之前，对象的值被其他线程连续修改两次，而且经过这两次修改之后，对象有恢复为旧值。这样，前后的结果看似没有被改过，但是其实已经被修改了2次。过程如下图：<br><img src="https://img-blog.csdn.net/20181010171642689" alt="在这里插入图片描述"></p><p>一般来说，发生这种事情的可能性很小。而且即使发生了也不会有什么影响，比如，一个数字，被修改一次后，在修改回去，不会对CAS产生什么影响。</p><p>但是有时候在一些具体问题中这种情况就有可能发生。所以在JDK中提供了AtomicStampedReference来解决这种问题。</p><h2 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h2><p>AtomicStampedReference在内部维护了一个时间戳。当AtmoicStampedReference对应的数字被修改时，除了更新数据本身，还必须更新时间戳。当AtomicStampedReference设置对象值时，对象和时间戳都必须满足期望值，才会写入成功。通过维护时间戳能有效的防止ABA问题。</p><p>AtmoicStampedReference的几个API在Atmomic的基础上新增了几个有关时间戳的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数为：期望值，新值，期望时间戳，新的时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> newStamp)</span></span>;</span><br><span class="line"><span class="comment">// 获取索引</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getReference</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取时间戳</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getStamp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 设置当前对象引用和时间戳</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V newReference, <span class="keyword">int</span> newStamp)</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java并发编程之无锁&quot;&gt;&lt;a href=&quot;#Java并发编程之无锁&quot; class=&quot;headerlink&quot; title=&quot;Java并发编程之无锁&quot;&gt;&lt;/a&gt;Java并发编程之无锁&lt;/h1&gt;&lt;p&gt;在谈论无所之前先来看看乐观派和悲观派。对于乐观派而言，他们总认为事情
      
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>数据库的事务和并发问题.md</title>
    <link href="http://yoursite.com/2019/04/06/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%92%8C%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98-md/"/>
    <id>http://yoursite.com/2019/04/06/数据库的事务和并发问题-md/</id>
    <published>2019-04-06T12:40:51.000Z</published>
    <updated>2019-04-07T02:18:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><p>事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么全部执行，要么全部都不执行。比如，银行转账，从一个账号扣钱，然后另一个账号余额增加，这两个操作要么都执行，要么都不执行。这两个操作组合在一起就是事务。</p><p>数据库事务有严格的定义，它必须同时满足4个特性：</p><ol><li>原子性，Atomic</li><li>一致性，Consistency</li><li>隔离性， Isolation</li><li>持久性，Durabiliy</li></ol><p>简称ACDI。下面是对每一个特性的说明：</p><ul><li>原子性：表示组成一个事务的多个数据库操作是一个密不可分的原子单元，只有所有的操作执行成功，整个事务才提交。事务中的任何一个数据库操作失败，已经执行的任何操作都必须撤销（回滚），让数据库恢复到事务提交之前的状态。</li><li>一致性：数据库总是从一个一致性状态装换到另一个一致性状态。一致性状态的含义是数据库中的数据应该满足数据库约束。</li><li>隔离性：在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对对方产生干扰。但是也并非要做到完全无干扰。数据库规定了多个隔离级别，不同的隔离级别的干扰程度是不同，隔离级别越高，数据一致性越好，但并发性越弱。</li><li>持久性：一旦数据库提交之后，事务中的所有操作都必须被持久化都数据库中。即使在提交事务后，数据库重启时，也必须保证能够通过某种机制恢复数据。</li></ul><p>在这些事务的特征中，数据”一致性“是最终目标，其他特性都是为达到这个目标而采取的措施。</p><h3 id="数据库并发的问题"><a href="#数据库并发的问题" class="headerlink" title="数据库并发的问题"></a>数据库并发的问题</h3><p>一个数据库可能会有多个客户端同时访问，数据库中相同的数据就有可能同时被多个事务访问，如果没有采取必要的隔离措施，就会导致各种问题，破坏数据的完整性，这些问题可以分为5中，两类：</p><ol><li>数据读取的问题：<ul><li>脏读</li><li>不可重复读</li><li>幻想读</li></ul></li><li>数据更新问题<ul><li>第一类丢失更新</li><li>第二类丢失更新</li></ul></li></ol><h4 id="1-脏读（direct-read）"><a href="#1-脏读（direct-read）" class="headerlink" title="1. 脏读（direct read）"></a>1. 脏读（direct read）</h4><p>A事务读取B事务尚未提交更改的数据，并在这个数据的基础上进行操作。如果恰巧B事务回滚，那么A事务读取到的数据是不被承认的。通过一个取款事务和转账事务来说明这个问题。</p><table><thead><tr><th style="text-align:center">时间</th><th style="text-align:center">转账事务A</th><th style="text-align:center">取款事务B</th></tr></thead><tbody><tr><td style="text-align:center">T1</td><td style="text-align:center"></td><td style="text-align:center">开始事务</td></tr><tr><td style="text-align:center">T2</td><td style="text-align:center">开始事务</td><td style="text-align:center">查询账户余额1000元</td></tr><tr><td style="text-align:center">T3</td><td style="text-align:center"></td><td style="text-align:center">取出500元，把余额改为500元</td></tr><tr><td style="text-align:center">T4</td><td style="text-align:center">查询余额500元（脏读）</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">T5</td><td style="text-align:center"></td><td style="text-align:center">撤销事务，余额恢复为1000元</td></tr><tr><td style="text-align:center">T6</td><td style="text-align:center">汇入100元，把余额改为600元</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">T8</td><td style="text-align:center">提交事务</td><td style="text-align:center">&nbsp;</td></tr></tbody></table><p>在这个场景中转账事务A读取到取款事务B中的未提交的数据，导致脏读。</p><h4 id="2-不可重复读-unrepeatable-read"><a href="#2-不可重复读-unrepeatable-read" class="headerlink" title="2. 不可重复读(unrepeatable read)"></a>2. 不可重复读(unrepeatable read)</h4><p>不可重复读是指A事务读取B事务已经提交更改的数据。假设A在取款事务的过程中，B往该账户转账100元，A两次读取账户的余额不一致。</p><table><thead><tr><th style="text-align:left">时间</th><th style="text-align:left">取款事务A</th><th style="text-align:left">转账事务B</th></tr></thead><tbody><tr><td style="text-align:left">T1</td><td style="text-align:left"></td><td style="text-align:left">开始事务</td></tr><tr><td style="text-align:left">T2</td><td style="text-align:left"></td><td style="text-align:left">开始事务</td></tr><tr><td style="text-align:left">T3</td><td style="text-align:left"></td><td style="text-align:left">查询账户余额为1000元</td></tr><tr><td style="text-align:left">T4</td><td style="text-align:left">查询账户余额1000元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">T5</td><td style="text-align:left"></td><td style="text-align:left">取出100元，把余额改为900元</td></tr><tr><td style="text-align:left">T6</td><td style="text-align:left"></td><td style="text-align:left"><strong>查询事务</strong></td></tr><tr><td style="text-align:left">T7</td><td style="text-align:left">查询账户余额为900元</td><td style="text-align:left">&nbsp;</td></tr></tbody></table><p>在同一事务中，T4和T7时间点读取的账户余额不一致。</p><h4 id="3-幻想读-phantom-read"><a href="#3-幻想读-phantom-read" class="headerlink" title="3. 幻想读(phantom read)"></a>3. 幻想读(phantom read)</h4><p>A事务读取B事务提交的新增数据，这时A事务将出现幻想读现象。幻想读一般发生在计算统计数据的事务中。</p><p>举个例子，比如在银行系统的同一个事务中有两次统计存款用户的总金额，在两次统计中刚好新增了一个存款，这时，两次统计的结构将会不一致。</p><table><thead><tr><th style="text-align:left">时间</th><th style="text-align:left">统计金额事务A</th><th style="text-align:left">转账事务B</th></tr></thead><tbody><tr><td style="text-align:left">T1</td><td style="text-align:left"></td><td style="text-align:left">开始事务</td></tr><tr><td style="text-align:left">T2</td><td style="text-align:left">开始事务</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">T3</td><td style="text-align:left">统计总存款为1000元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">T4</td><td style="text-align:left"></td><td style="text-align:left">新增一个存款账户，存款100元</td></tr><tr><td style="text-align:left">55</td><td style="text-align:left"></td><td style="text-align:left">提交事务</td></tr><tr><td style="text-align:left">T6</td><td style="text-align:left">再次统计总存款数为10100元（幻想读）</td><td style="text-align:left">&nbsp;</td></tr></tbody></table><p>如果新增的数据刚好满足事务的查询条件，那么这个新数据就会出现事务的视野中，因而产生了两次结构不一致。</p><p>幻想读和不可重复读这两个概念比较容易混淆<br>，幻想读是指读到了其他已经提交的事务的新增数据，而不可重复读是指读到了已经提交的更改数据（更改或者删除）。</p><p>为了避免这两种情况，采取的对策是不同的：防止读到更新的数据，只需要对操作的数据添加行级锁，阻止操作中的数据发生改变；而防止读到新增的数据，则往往需要添加表级锁——将整张表加锁，防止新增数据。</p><h4 id="4-第一类丢失更新"><a href="#4-第一类丢失更新" class="headerlink" title="4. 第一类丢失更新"></a>4. 第一类丢失更新</h4><p>第一类丢失更新是一个事务撤销时把另一个事务的数据覆盖了。下面通过一个转账的例子来看一下这个问题。</p><table><thead><tr><th style="text-align:left">时间</th><th style="text-align:left">取款事务A</th><th style="text-align:left">转账事务B</th></tr></thead><tbody><tr><td style="text-align:left">T1</td><td style="text-align:left">开始事务</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">T2</td><td style="text-align:left"></td><td style="text-align:left">开始事务</td></tr><tr><td style="text-align:left">T3</td><td style="text-align:left">查询余额为1000元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">T4</td><td style="text-align:left"></td><td style="text-align:left">查询余额为1000元</td></tr><tr><td style="text-align:left">T5</td><td style="text-align:left"></td><td style="text-align:left">汇入100元，把余额修改为1100元</td></tr><tr><td style="text-align:left">T6</td><td style="text-align:left"></td><td style="text-align:left">提交事务</td></tr><tr><td style="text-align:left">T7</td><td style="text-align:left">取出100元，把余额修改为900元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">T8</td><td style="text-align:left">撤销修改</td><td style="text-align:left">&nbsp;</td></tr><tr><td style="text-align:left">T9</td><td style="text-align:left">把余额恢复为1000元（丢失更新）</td><td style="text-align:left">&nbsp;</td></tr></tbody></table><h4 id="5-第二类丢失更新"><a href="#5-第二类丢失更新" class="headerlink" title="5. 第二类丢失更新"></a>5. 第二类丢失更新</h4><p>一个事务覆盖另一个事务已经提交的数据。造成另一个事务所做的操作丢失。</p><table><thead><tr><th style="text-align:left">时间</th><th style="text-align:left">取款事务A</th><th style="text-align:left">转账事务B</th></tr></thead><tbody><tr><td style="text-align:left">T1</td><td style="text-align:left"></td><td style="text-align:left">开始事务</td></tr><tr><td style="text-align:left">T2</td><td style="text-align:left">开始事务</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">T3</td><td style="text-align:left"></td><td style="text-align:left">查询账户余额为1000元</td></tr><tr><td style="text-align:left">T4</td><td style="text-align:left">查询账户余额为1000元</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">T5</td><td style="text-align:left"></td><td style="text-align:left">取出100元，把余额修改为900元</td></tr><tr><td style="text-align:left">T6</td><td style="text-align:left"></td><td style="text-align:left">提交事务</td></tr><tr><td style="text-align:left">T7</td><td style="text-align:left">汇入100元</td><td style="text-align:left">&nbsp;</td></tr><tr><td style="text-align:left">T8</td><td style="text-align:left">提交事务</td><td style="text-align:left">&nbsp;</td></tr><tr><td style="text-align:left">T9</td><td style="text-align:left">把余额修改为1100元（丢失更新）</td><td style="text-align:left">&nbsp;&nbsp;</td></tr></tbody></table><p>总结：第一类为撤销时覆盖，第二类为提交时覆盖。</p><h3 id="数据库锁机制"><a href="#数据库锁机制" class="headerlink" title="数据库锁机制"></a>数据库锁机制</h3><p>数据库的并发会引起很多问题，当然有些问题还可以容忍，但是有的问题却是致命的。并发问题一般都会用锁解决，在数据库中也是用锁解决的，但是不同的数据库对于锁的实现是不同的，但基本的原理是相同。</p><p>按锁定的对象可以分为：</p><ul><li>表锁定：对于整张表锁定</li><li>行锁定：对于表中的特定行锁定</li></ul><p>从并发的数据关系中又可以分为</p><ul><li>独占锁：共享锁会防止独占锁，但允许其他共享锁的访问。</li><li>共享锁：独占锁独自占领表或行，防止其他共享锁的访问，当然也访问其他独占锁。</li></ul><p>在数据更新的时候，数据库必须在进行更改的行上施加行独占锁，也就是说INSERT,UPDATE,DELETE等语句都会隐式采用必要的行锁定。</p><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>尽管数据库为用户提供了锁的DML操作方式，但是直接使用还是很麻烦的，因此数据库为用户提供了自动锁的机制。也就是隔离级别，只要用户指定的回话的隔离级别，数据库就会分析SQL语句，然后进行合适的加锁，当数据锁的数据太多的时候，自动进行锁升级来提高系统的，性能，这一过程对用户是透明的（不可见）的。</p><p>SQL标准定义了4个事务级别，每一个级别都规定了一个事务中所做的修改，哪些在事务中是可见的，哪些是不可见的。较低的隔离通常可以执行更高的并发，系统开销也更低。</p><p>下面的是四中数据库事务的介绍：</p><ol><li>READ UNCOMMITED（未提交读）<br>事务中的修改，即使没有提交对其它事务都是可见的。事务可以读取未提交的数据，这也被称为脏读。一般很少使用。</li><li>READ COMMITED（提交读）<br>大多数的数据库的默认隔离级别都是READ COMMITED。READ_COMMITED从一个事务开始时，只能”看见“已经提交的修改。也就是说：一个事务从开始到提交前，所做的任何修改对其他事务是不可见的。这个级别有时候也叫做不可重复读，因为两次执行查询可能会得到不同的结果。</li><li>REPEATABLE READ（可重复读）<br>REPEATABLE READ解决了脏读的问题，该级别保证在同一个事务中多次读取同样的记录的结果是一致的。但是这个级别还是没有解决另一个问题：幻读。</li><li>SERIALIZABLE（可串行化）<br>SERIALIZABLE是最高的隔离级别。它通过事务串执行，避免了前面所说的幻读问题。简单来说SERIALIZABLE会为每一行数据都加锁，所以会导致大量的锁超时和竞争。实际中很少使用这个隔离级别。</li></ol><p>下表为事务隔离级别对并发问题的解决情况：</p><table><thead><tr><th style="text-align:left">隔离级别</th><th style="text-align:left">脏读</th><th style="text-align:left">不可重复读</th><th style="text-align:left">幻想读</th><th style="text-align:left">第一类丢失更新</th><th style="text-align:left">第二类丢失更新</th></tr></thead><tbody><tr><td style="text-align:left">READ UNCOMMITED</td><td style="text-align:left">允许</td><td style="text-align:left">允许</td><td style="text-align:left">允许</td><td style="text-align:left">不允许</td><td style="text-align:left">允许</td></tr><tr><td style="text-align:left">READ COMMITED</td><td style="text-align:left">不允许</td><td style="text-align:left">允许</td><td style="text-align:left">允许</td><td style="text-align:left">不允许</td><td style="text-align:left">允许</td></tr><tr><td style="text-align:left">REPEATABLE READ</td><td style="text-align:left">不允许</td><td style="text-align:left">不允许</td><td style="text-align:left">允许</td><td style="text-align:left">不允许</td><td style="text-align:left">不允许</td></tr><tr><td style="text-align:left">SERIALIZABLE</td><td style="text-align:left">不允许</td><td style="text-align:left">不允许</td><td style="text-align:left">不允许</td><td style="text-align:left">不允许</td><td style="text-align:left">不允许</td></tr></tbody></table><p>其中READ UNCOMMITED并发性和吞吐量最好，SERIALIZABLE的最差，所以事务的隔离级别和数据库的并发行是对立的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据库事务&quot;&gt;&lt;a href=&quot;#数据库事务&quot; class=&quot;headerlink&quot; title=&quot;数据库事务&quot;&gt;&lt;/a&gt;数据库事务&lt;/h1&gt;&lt;p&gt;事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么全部执行，要么全部都不
      
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
